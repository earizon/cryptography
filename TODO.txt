## ./WhyAndHow_zkSNARK_Works_1906.07221.pdf  @ma

## "Elliptic Curves and Modular Forms | The Proof of Fermat’s Last Theorem" en YouTube [[{]]
https://youtu.be/grzFM5XciAY
Ver comentarios!!!
[[}]]


## GPG summary [[{]]
https://github.com/tldr-pages/tldr/blob/master/pages/common/gpg.md
https://github.com/tldr-pages/tldr/blob/master/pages/common/gpg2.md
- https://github.com/tldr-pages/tldr/blob/master/pages/common/gpgv.md
  Verify OpenPGP signatures.
  More information: https://www.gnupg.org/documentation/manuals/gnupg/gpgv.html.
[[}]]

## Starred projects at github,  Includes many related to cryptography [[{]]
https://github.com/mayakacz?after=Y3Vyc29yOnYyOpK5MjAxNi0wNS0wNlQwNzowNToyMSswMjowMM4DeoYC&tab=stars
[[}]]

## [Announce] Libgcrypt 1.9.0 relased [[{]]
 https://lists.gnupg.org/pipermail/gnupg-announce/2021q1/000453.html
[[}]]



#######################
https://crypto.stackexchange.com/tags  @ma Crypto Taxonomy!!!!
https://en.wikipedia.org/wiki/Commitment_scheme#Partial_reveal

#############################
What's new: OpenSSL
https://blog.segu-info.com.ar/2021/09/publicado-openssl-v30.html?m=1

https://www.openssl.org/docs/man3.0/man7/crypto.html

## Google HIBA: OpenSSH Add-On for Certificate-Based Authorization [[{]]
Google publishes HIBA, an OpenSSH Add-On for Cert.-Based Authorization
https://www.linuxtoday.com/security/google-publishes-hiba-an-openssh-add-on-for-certificate-based-authorization/
[[}]]

## Google Open-Sources Fully Homomorphic Encryption Transpiler [[{]]
https://www.infoq.com/news/2021/06/google-fhe-transpiler/

Google has open-sourced a general-purpose transpiler able to convert high-level code to be used with Fully Homomorphic Encryption (FHE).

While FHE is attracting a lot of interest from several companies,
including IBM and Microsoft, here Google is attempting a novel
approach by creating a transpiler to transform a program written in a
high-level language and working with non-encrypted data into an
FHE-ready version.
  Google’s transpiler will enable developers to write code for any
type of basic computation such as simple string processing or math,
and run it on encrypted data.
[[}]]

## 1Password Plugin Password Manager  [[{]]
https://chrome.google.com/webstore/detail/1password-%E2%80%93-password-mana/aeblfdkhhhdcdjpifhhbdiojplfjncoa?hl=en
Developed in Rust. Compiled to wasm.
[[}]]

## Convert keys GPG|OpenSsh|OpenSSL [[{standards.pgp,tool.gpg,tool.openssl]]
[[{protocol.ssh,protocol.tls.ca,PM.TODO]]
http://sysmic.org/dotclear/index.php?post/2010/03/24/Convert-keys-betweens-GnuPG%2C-OpenSsh-and-OpenSSL
[[}]]


@[http://www.xataka.com/privacidad/enigma-renace-el-cifrado-homomorfico-y-el-blockchain-como-base-de-una-internet-mas-privada]

## Quadratic Arithmetic 101 [[{]]
  @[https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649]
  @[https://blog.plan99.net/vntinyram-7b9d5b299097]
  @[https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649]
  • zero-knowledge proof: cryptographic method where one party
    (the prover) can prove to another party (the verifier) that the prover
    knows a value x, without conveying any information apart from the fact
    that the prover knows the value x.
[[}]]

## forge: Native implementation of TLS in JS [[{]]
https://github.com/digitalbazaar/forge
[[}]]

----------------------
## Proxy Re-encryption (PRE) [[{qa.UX]]
 https://www.nucypher.com/proxy-re-encryption
  Proxy re-encryption (PRE) is a type of public-key encryption (PKE)
  that allows a proxy entity to transform or re-encrypt data from one
  public key to another, without having access to the underlying
  plaintext or private keys.

  - Alice uses PrivKey_a to decrypt PubKey_a messages.
  - Alice generates re-encryption PubKey_a_to_b (a_to_b == "Alice 2 Bob")
    and sends it to trusted PROXY (e.g: e-mail server)
  - PROXY uses the PubKey_a_to_b to re-encrypt any messages
    arriving signed with PubKey_a.
  - Bob now can fetch the new encrypted-with-PubKey_a_to_b message
    and decrypt it with its own private key.
  - The PROXY has no way to decrypt the original or new encrypted messages
[[}]]

## SHA-256 visualized [[{]]
 El algoritmo SHA-256 explicado y visualizado paso a paso, bit a bit
https://www.microsiervos.com/archivo/seguridad/algoritmo-sha-256-explicado-visualizado-paso-a-paso-bit-a-bit.html
[[}]]

## Linux support for EFI [[{]]
https://www.linuxadictos.com/linux-5-19-ya-fue-liberado-y-estas-son-sus-novedades.html 
* El subsistema EFI implementa la capacidad de transferir de forma
  confidencial información secreta a los sistemas invitados sin
  revelarla al sistema host. Los datos se proporcionan a través del
  directorio security/coco en securityfs.
* el modo de seguridad de bloqueo, restringe el acceso de root al
  kernel y bloquea las rutas de omisión de arranque seguro de UEFI.
* Se agregó soporte para la extensión AMD SEV-SNP (paginación anidada
  segura), que brinda trabajo seguro con tablas de páginas de memoria
  anidadas y protege contra ataques «undeSErVed» y «SEVerity» en los
  procesadores AMD EPYC, que permiten eludir la extensión AMD SEV
  (virtualización cifrada segura). )
* Se agregó soporte para Intel TDX (Trusted Domain Extensions), que
  permite bloquear los intentos de acceso de terceros a la memoria
  cifrada de la máquina virtual.
[[}]]


## Arch.considerations for cryptanalytic hardware:
@[https://people.eecs.berkeley.edu/~daw/papers/hwkeysearch96-www/chap-10_local.html]

## Extract Key from Java Keystore [[{tech_stack.java,secret_mng.wallet,use_case.secret_mng}]]
https://dzone.com/articles/extracting-a-private-key-from-java-keystore-jks
https://medium.com/java-user-group-malta/importing-existing-certificates-into-a-keystore-using-openssl-905d9e0b7175

## Toplip: Strong File encrypt [[{use_case.secret_mng,01_PM.low_code,tool}]]
@[https://www.ostechnix.com/toplip-strong-file-encryption-decryption-cli-utility/]

## Titan: Cli pass.manager:
https://www.ostechnix.com/titan-command-line-password-manager-linux/

## AMD Sec.Processor: Mem.Encryption[[{use_case.secret_mng,secret_mng.hardware,secret_mng.wallet}]]
https://www.techpowerup.com/review/amd-epyc-server-architecture/3.html

## Chinesse Standards: SM2, SM3, SM4 replace RSA, SHA , AES

## Post Quantum Guide:
https://hackernoon.com/a-guide-to-post-quantum-cryptography-d785a70ea04b

## BLS Signature Scheme:[[{use_case.signature,crypt_asymmetric,01_PM.TODO]]
@[https://medium.com/@srikarv/the-bls-signature-scheme-a-short-intro-801c723afffa]
... Some prominent encryption schemes in literature and the fundamental
reasoning behind their formulation include:
- Boneh — Lynn — Shacham (BLS): Based on the existence of random
  oracles and the intractability of the computational Diffie-Hellman
  problem in a gap Diffie-Hellman group.
- ElGamal: Based on the hardness of the discrete logarithm problem.
- ECDSA: Based on the fact that given a point A on an elliptic curve
  and another point P = n*A, it is difficult to find n.
- RSA: Factorization of numbers (semi-primes in particular) is hard.
- Schnorr Signature: Based on the hardness of the discrete logarithm problem.
[[}]]

## Pairing primitives  [[{use_case.signature.aggregated,01_PM.TODO]]
@[https://www.math.uwaterloo.ca/~ajmeneze/publications/pairings.pdf]
  Bilinear pairings have been used to design ingenious
  protocols for such tasks as one-round three-party key agreement,
  identity-based encryption,and aggregate signatures. Suitable bilinear
  pairings can be constructed fromthe Tate pairing for specially chosen
  elliptic curves.  Thisarticle gives anintroduction to the protocols,
  Tate pairing computation, and curve selection.
[[}]]

## Trusted Signature Pad: use_case.signature,hardware
https://www.google.com/search?q=trusted+signature+pad

## Aggregated Signatures[[{use_case.signature.aggregated,02_doc_has.comparative,01_PM.WiP]]
REF: @[https://arxiv.org/pdf/1911.04698.pdf]
Aggregate Signature protocols:
.... CoSi protocol is based on SCHNORR SIGNATURE AGGREGATION,
     which is an INTERACTIVE protocol:
     aggregated Schnorr-signature for a single message
     requires all  the  singers  collaboration to generate
     1) shared challenge-string in the "Challenge" phase of CoSi-protocol.
     2) challenge-string of 1) as input for each signer to
        generate its SIGNATURE SHARE.
     Hence:
     - A LEADER IS REQUIRED TO ORCHESTRATE THE WHOLE PROCESS.
     - protocol  needs  to  take  multiple  rounds.

 ...  our  aggregated  signature  gossip  protocol is based on
      NON-INTERACTIVE BLS SIGNATURE AGGREGATION SCHEME.
     Hence:
     - coordination  among nodes is eliminated.
     - instead  of communication tree, gossip protocol is
       used to propagate the aggregated signatures.
     These lead to simple+robust design which could be easier
     to implement in practice.
[[}]]

## Fully Homomorphic Encryption (FHE) SDK:
IBM Launches Fully Homomorphic Encryption (FHE) Toolkit for Linux - 9to5Linux
@[https://9to5linux.com/ibm-launches-fully-homomorphic-encryption-fhe-toolkit-for-linux]

## Trusted Data Format (TDF):[[{standards.web]]
@[https://github.com/virtru/tdf-spec]

- Trusted Data Format (TDF) is an Open, Interoperable, JSON encoded
   data format for implementing Data Centric Security for objects (such
   as files or emails). This repository specifies the protocols and
   schemas required for TDF operation.

- manifest.json  ··(references) ··> encrypted payload file/s

- HTML+css , manifest.json ··(references) ··> Encrypted payload/s

- There are three principle element-types within a TDF's manifest.json:
  - Encryption Information: for encrypting, signing, or integrity
    binding of Payloads and Assertions.
  - Payload Reference(s): reference(s) to the encrypted payload.
  - Assertion(s): statement(s) about payload(s); this is optional and
    not shown below.


## (Quantum)Lamport Signature:[[{use_case.signature,crypt_asymmetric]]
- quantum-proof cryptographic signatureS
- Quantum Safe Ethereum proxy with
  Winternitz One-Time signatures
  @[https://github.com/tjade273/QEth]
[[}]]

## https://academy.bit2me.com/en/que-es-wallet-mpc/  MPC: Multi Party Computing
Due to its great possibilities, the community cripto has remained
strongly interested in this type of technology. In fact, David Chaum
In 1988, he presented a well-known work under the name of
"Unconditionally secure multi-party protocols". On the other hand,
Nick Szabo, in 1999 he also presented a well-known work called "God's  <·····!!!
protocols", also explaining the possibilities of MPCs in the world of
computing and their use in economic and financial systems. This
offers us a clear idea of the importance of these protocols,
and their arrival in the world of cryptocurrencies.


## The God Protocols: November 15, 1999, Nick Szabo,
  https://web.archive.org/web/20061230075325/http:/www.theiia.org/ITAudit/index.cfm?act=itaudit.archive&fid=216

  Acknowledgement: This article first appeared in Nick Szabo's
  E-Commerce and Security White Papers (http://www.best.com/~szabo/)
  and is reprinted with permission from the author, Nick Szabo, who
  holds the copyright.
  Imagine the ideal protocol. It would have the most trustworthy third
  party imaginable — a deity who is on everybody's side. All the
  parties would send their input to this god. God would reliably
  determine the results and return the output. In addition, God, being
  the ultimate in confessional discretion, would ensure that no party
  would learn anything more about the other party's input than they
  could learn from their own input and the output.

  Alas, in our temporal world we deal with humans rather than deities.
  Yet, too often we are forced to treat people in a nearly god-like
  manner because our infrastructure lacks the security needed to
  protect ourselves.

  Trusted Third Party:

  F1

  To an astonishing extent, network security theorists have recently
  solved this problem. They have developed protocols that create
  virtual machines between two or more parties. Multi-party secure
  computation allows any number of parties to share a computation, each
  learning only what can be inferred from their own input and the
  output of the computation. These virtual machines have the exciting
  property that each party's input is held in strict confidence from
  the other parties. The program and the output are shared by the
  parties.

  For example, we could run a spreadsheet across the Internet on this
  virtual computer. We would agree on a set of formulas and set up the
  virtual computer with these formulas. Each participant would have
  their own input cells, which remain blank on the other participants'
  computers. The participants share output cell(s). Each participant
  inputs their own private data into their input cells. Alice could
  only learn as much about the other participants' input cells as she
  could infer from her own inputs and outputs.

  Mathematically Trustworthy Protocol:

  F2

  There are three major limitations. The first is that this virtual
  computer is very slow: in some cases, one arithmetic calculation per
  network message. Currently, it is at best practical only for small
  logic or arithmetic calculations used as an adjunct to or component
  of more efficient computations and protocols.

  The second is that there is a tradeoff between privacy, fairness, and
  fault tolerance. Fairness means everybody learning the results in
  such a way that no one can gain an advantage by learning first. Fault
  tolerance can provide robustness against a minority, so that it takes
  a majority dropping out to halt the protocol, or it can be non-robust
  but fail-stop, so that a single participant can terminate the
  protocol. Many papers have discussed the fraction of parties one must
  trust in order to be assured of learning the correct output. In
  traditional results, fairness and privacy could not both be achieved
  with a faulty majority. Recent papers [3-6] have produced fair and
  private protocols even with faulty majorities. They trade robustness
  for privacy and fairness against any proportion of faulty parties.
  The advantage of this fail-stop approach is that you can usually find
  new partners and start over again, but you don’t want to suffer
  irreversible losses such as leaking information, being left holding
  the bag, or being convinced of an incorrect result.

  The third limitation is that, far from being omniscient or
  omnipotent, the protocol will accomplish only what is specified in
  the algorithm and the inputs. It won't be able to replace
  human-trusted third parties where those parties provide insight or
  knowledge that cannot be provided by a computer.

  With these caveats, any algorithmic intermediary can, in principle,
  be replaced by a trustworthy virtual computer. In practice, because
  of the three limitations, we usually construct more limited protocols
  out of more efficient elements.

  Multi-party computation theory has major implications, in theory, for
  all kinds of contractual relationships. This can be seen most clearly
  in the area of negotiations. A mechanism in economics is an abstract
  model of an institution which communicates with its participants via
  messages, and whose rules can be specified algorithmically. These
  institutions can be auctions, exchanges, voting, and so on. They
  typically implement some kind of negotiation or decision-making
  process.

  Economists assume a trusted intermediary operates the mechanism.
  Here's a simple example of using this virtual computer for a
  mechanism. Alice can submit a bid price, and Bob an ask price, then
  their shared virtual program which has one instruction, "A greater
  than B?" The computer then returns "true" if Alice's bid is greater
  than Bob's offer. A slightly more sophisticated computer may then
  decide the settlement price according to a number of different
  algorithms (Alice's bid, Bob's ask, split the difference, etc.). This
  implements the mechanism blind bargaining with no trusted
  intermediary.

  In principle, since any computable problem can be solved on this
  virtual computer (they are Turing complete), any computable economic
  mechanism can be implemented without a trusted intermediary. In
  practice, we face the three limitations discussed previously, but the
  proof that any economic mechanism can be run without a trusted
  intermediary is very exciting. This means that, in principle, any
  contract that can be negotiated through a trusted third party (such
  as an auction or exchange) can be negotiated directly. So, in some
  abstract sense, the only remaining hard problems in smart contract
  negotiations are (a) problems considered hard even with a trusted
  intermediary (for the standard economic reasons), and (b) the task of
  algorithmically specifying the negotiating rules and output contract
  terms. (This includes cases where an intermediary adds knowledge
  unavailable to the participants, such as a lawyer giving advice on
  how to draft a contract.) In practice, many problems that can be
  solved in principle with multi-party computation will reoccur when we
  implement protocols in an efficient, practical manner. The God
  Protocols give us a target to shoot for.

  Applying this kind of analysis to the performance phase of contracts
  is less straightforward. For starters, economic theories of the
  performance phase are not as well developed or simple as the
  mechanism theory of negotiations. Indeed, most economic theory simply
  assumes that all contracts can be perfectly enforced cost-free. Some
  of the transaction cost literature has started to move beyond this
  assumption, but there are few compelling results or consensus
  theories in the area of techniques and costs of contract enforcement.

  Performance phase analysis with multi-party secure computer theory
  would seem to apply only to those contracts that can be performed
  inside the virtual computer. But the use of post-unforgeable auditing
  logs, combined with running auditing protocols inside the shared
  virtual computer, allows a wide variety of performances outside the
  virtual computer to at least be observed and verified by selected
  arbitrators.

  The participants in this mutually confidential auditing protocol can
  verify that the books match the details of transactions stored in a
  previously committed transaction log, and that the numbers add up
  correctly. The participants can compute summary statistics on their
  confidentially shared transaction logs, including cross-checking of
  the logs against counterparties to a transaction, without revealing
  those logs. They only learn what can be inferred from the statistics,
  cannot see the details of the transactions. Another intriguing
  possibility is that the virtual computer can keep state over long
  periods of time, allowing sophisticated forms of privy and
  self-enforcing secured credit.

  If mutually confidential auditing ever becomes practical, we will be
  able to gain high confidence in the factuality of counterparties'
  claims and reports without revealing identifying and other detailed
  information from the transactions underlying those reports. These
  would provide the basis for solid reputation systems, and other
  trusted third-party systems, that maintain integrity across time,
  communications, summarization, and preserve confidentiality for
  transaction participants. Knowing that mutually confidential auditing
  can be accomplished in principle will hopefully lead us to practical
  solutions to these important problems.

  References
  [1] D. Chaum, C. Crépeau, and I. Damgaard, Multiparty
  unconditionally secure protocols; In 19th Symp. on Theory of
  Computing, pages 11-19. ACM, 1988.
  [2] "The Spymasters Double Agent Problem: Multiparty Computations
  Secure Unconditionally from Minorities and Cryptographically from
  Majorities," D. Chaum, Advances in Cryptology CRYPTO'89, G. Brassard
  (Ed.), Springer-Verlag, pp. 591-601.
  [3] C. Crépeau, J. van de Graaf, and A. Tapp, Committed Oblivious
  Transfer and Private Multi-Party Computations; Advances in
  Cryptology: Proceedings of Crypto '95, Springer-Verlag, pages
  110-123, 1995.
  [4] Complete Characterization of Adversaries Tolerable in Secure
  Multi-Party Computation, Martin Hirt and Ueli Maurer. Computer
  Science Department, ETH Z¨¹rich. 1997. in Proceedings of PODC '97
  [5] Matthias Fitzi, Martin Hirt, and Ueli Maurer: Trading correctness
  for privacy in unconditional multi-party computation. In Advances in
  Cryptology — CRYPTO '98, volume 1462 of Lecture Notes in Computer
  Science, 1998.
  [6] R. Cramer, I. Damgaard, S. Dziembowski, M. Hirt, T. Rabin,
  Efficient Multi-Party Computations with Dishonest Majority,
  Proceedings of Eurocrypt '99, Springer Verlag LNCS, to appear (May
  '99).
--------------------------
https://github.com/google/native-pkcs11

native-pkcs11 is a crate for building PKCS#11 modules.

primary use-case: authenticating with client certificates.
aims to support native certificate stores (MacOS Keychain, Windows Platform Key Provider) out of the box. It can also be extended with a custom backend (see this section).

currently tested with:
    openssh
    openvpn
    Chrome
    Firefox
-------------------------
https://github.com/BlockchainCommons/Gordian-Developer-Community
Gordian Developer Community is a community of cryptocurrency & identity wallet developers, sharing best practices for paritioned interoperability among multiple vendors on multiple platforms. These best practices include support for hot, cold and multisig cryptographic wallets, research & proposals for data formats and protocols, usage of gaps such as airgaps and torgaps, security and UX for multisig work flows, and other key management and signing issues and topics, particularly those that support the Gordian Principles of independence, privacy, resilience, and openness.
------------------------
https://github.com/starkware-libs/cairo
Cairo is the first Turing-complete language for creating provable programs for general computation.
-----------------------------
https://blake12.org/
-------------------------------
# DNSSEC
# Validate DNSSEC from cli [[{protocol.dnssec,use_case.data_integrity,use_case.identity,use_case.IoT,01_PM.TODO]]
@[https://www.cyberciti.biz/faq/unix-linux-test-and-validate-dnssec-using-dig-command-line/]
[[}]]
-----------------------
[[{use_case.AAA.activeDirectory]]
# kerberos+ldap "=" Active Directory.
## Kerberos protocol: [[{protocol.kerberos,crypt_symmetric,crypt_asymmetric]]
@[https://en.wikipedia.org/wiki/Kerberos_(protocol)]
@[https://web.mit.edu/Kerberos/]
- computer-network protocol designed to
  provide strong client/server mutual authentication

-  built on symmetric key cryptography  and
   may (optionally) use public-key cryptography
   during certain phases of authentication
-  requires a trusted third party
-  works on the basis of tickets
- allow nodes communicating over a non-secure network
  to prove their identity to one another in a secure manner,
  protecting against eavesdropping and replay attacks.

 History and development
- 19?? MIT 1st Kerberos version
  based on the earlier Needham–Schroeder symmetric key protocol.
- Versions 1-3 were only MIT internals.

- Late 1980s: version 4 (by Steve Miller and Clifford Neuman)

- 1993: Version 5, becomes also RFC 1510

- 2000: Default authentication method in Windows 2000
        - RFC 3244 documents Microsoft additions to the standard
          suite of protocols:
        "Microsoft Windows 2000 Ker. Change and Set Password Proto."
        RFC 4757 documents Microsoft's use of the RC4 cipher.
        Kerberos is used as preferred authentication method:
        In general, joining a client to a Windows domain means
        enabling Kerberos as default protocol for authentications
        from that client to services in the Windows domain and
        all domains with trust relationships to that domain.
       (fallback to NTLM ifeither client or server are not joined to a domain*


- 2005: RFC 4120 makes (1993) RFC 1510 obsolet. Updates by IETF included:
  - Encryption and Checksum Specifications (RFC 3961)
  - AES (RFC 3962)
  - new edition of the Kerberos V5 spec
    "The Kerberos Network Authentication Service (V5)" (RFC 4120).
  - new edition of
    "The Kerberos V5 Generic Security Service API (GSS-API) Mechanism: Version 2." (RFC 4121).

- 2???: MIT implementation freely available (BSD license)

- 2007: MIT formed the Kerberos Consortium to foster continued development.
        Founding sponsors include Oracle, Apple, Google, Microsoft, Centrify Corporation, TeamF1,
        Royal Institute of Technology in Sweden, Stanford University, MIT, CyberSafe.

 Protocol Description

participant client
participant Service Server          as SS
participant Auth.Server             as AS
participant Key.Distribution.Center as KDC
participant Ticket.Gathering.System as TGS
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Ussually KDC and TGS share the
            same host

PRE-SETUP: Register SPN at TGS with a Service Principal Name (SPN01)
SS → TGS: Register SPN01

LOGIN-FASE: Gathering new TGT (ticket-granting ticket)
  client →  client: username01, password01
  client →  client: alt 1: key01 = chiper(secret_key, password01)
                    alt 2: key01 = hash  (password01)
  client →  AS: username01
  AS     → KDC: username01
  KDC    → KDC: issues new TGT01
                           -----
                           - time-stamp
                           - expiration-time

  KDC    → KDC: encryptedTGT01 = sym_cipher(secret_key, TGT01)
  KDC    → client: encryptedTGT01 (usually at user logon)


STEP 2: Communicating with other nodes ("principal")
  client → TGS: TGT01 + SPN01
                        ^^^^^
                        SPN01 registered in PRE-SETUP.
  TGS    → TGS: verify TGT01
                verify client is allowed access to TG01
  TGS    → client: Session Ticket st01 + Session Keys
  client → SS: session ticket st01 + sess.keys + service request

 Drawbacks and limitations
- Kerberos requires user accounts, user clients
  and the services on the server to all have a
  trusted relationship to the Kerberos token server
  All must be in the same Kerberos domain or in domains
  that have a trust relationship between each other.
  - creating staged environments (e.g. separate domains for
    test, pre-production, production) is difficult.


 Kerberos delegation
- Kerberos delegation is used in multi-tier application/service situations:
-  A common scenario would be a web server application making calls to
   a database running on another server.
   -  The first tier is the user who browses to the web site’s URL.
   -  The second tier is the web site.
   -  The third or data tier would be the database.
   Delegation allows the database to know who is actually accessing its data

  Non-Kerberos Security Setup:
    webserver_admin → database1_admin : request database  access for "WebServerAcct"
    database1_admin → database1_admin : grant "sufficient" access to "Database1Acct"
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    webapp developers and/or admins determine who can access the web application
    and by extension the data in the back end.
      (it may be unacceptable to the database admins as they cannot control wh
       ultimately has access to the data)

  Kerberos delegation Setup:
    - grant "WebServerAcct" permission to delegate to the "Database1Acct".
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      When a user accesses the web site they authenticate with Windows Integrated Authentication:
      user → webserver: request + user-kerberos-ticket1
                                  ^^^^^^^^^^^^^^^^^^^^^
                                  contains a list of the user's
                                  AD group memberships.

      webserver → webserver: check that user-kerberos-ticket1 is in Database group
      webserver → AD controller: (delegation configure)
                                 request a Kerberos ticket to the database
                                 impersonating the user rather than "WebServerAcct"
      ...
      webserver → Database1: request + user-kerberos-ticket2
      Database1 → Database1: check that user-kerberos-ticket1 is allowed
[[}]]

## LDAP [[{use_case.AAA.activeDirectory,protocol.LDAP]]
@[https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol]

- application protocol for accessing and maintaining distributed
  directory information services over an Internet Protocol (IP) network.

- Directory services roles:
  - share information about users and services throughout the network,
    like mails, phones, user/passwords, ...

 History
- 1980s: Telco companies develop the concept of directory services
         culminating in the comprehensive X.500 specification
         by the International Telecommunication Union (ITU) in the 1980s.

- 1993 : First version created as a subset of X.500 for TCP/IP
         While the X.500 was "heavy" in network bandwith, LDAP was
         "light", better suited for TCP/IP at that time.

- 1997: LDAPv3
        - added support for extensibility
        - integrates Simple Authentication and Security Layer

- 2006: Latest version (RFC 4511)
        road map to the technical specifications is provided by [RFC4510]
        - The Protocol [RFC4511]
        - Directory Information Models [RFC4512]
        - Authentication Methods and Security Mechanisms [RFC4513]
        - Uniform Resource Locator [RFC4516]
        - ...

 Protocol overview
- ASN.1 binary BER encoded (Basic Encoding Rules)

participant Directory_System_Agent (LDAP_server) as DSA
client → DSA: connect
client → DSA: operation request  ← With some exceptions, client does
client ← DSA: operation response   not need to wait for a response
              ^^^^^^^^^            before sending the next request.
                │                  Server may respond in any order.
       ┌────────┘
 operation can be:
 - StartTLS    :
 - Bind        : authenticate and specify LDAP protocol version
 - Search      : search for and/or retrieve directory entries
 - Compare     : test if a named entry contains a given attribute value
 - Add    entry:
 - Delete entry:
 - Modify entry:
 - Modify DN   : move/rename an (D)istinguished (N)ame
 - Abandon     : abort a previous request
 - Extended Op : generic operation used to define other operations
 - Unbind      : close the connection (not the inverse of Bind)

 Directory structure
- (Follows X.500 1993 model)
- attribute = [ name, value+]
- attributes are defined in a schema
- entry == [parent DN, Relative DN  , [attribute1, attribute2,...] ]
                       ─────────────   ──────────  ──────────
                       att name: cn    name        name
                       att value:...   val1        val1,val2
                       └───────────┘
                        Relative
                        Distinguished
                        Name
            └───────────────────────┘
             Distinguished Name (DN)

      Example entry in LDIF format
      (LDAP Data Interchange Format)
                                           (Mentally)
   ┌─→dn: cn=John Doe,dc=example,dc=com  ← /com/example/John Doe
   │      └───────────────────────────┘    └──────────┘ └──────┘
   │        Distinguished Name (DN)         Parent DN     RDN
   │  cn: John Doe                         └───────────────────┘
   │  givenName: John                              DN
   │  sn: Doe
   │  telephoneNumber: +1 888 555 6789               ┌────  Each entry must have an objectClass
   │  telephoneNumber: +1 888 555 1232               │      attribute, containing named classes
   │  mail: john@example.com                         │      defined in the schema.
   │  manager: cn=Barbara Doe,dc=example,dc=com      │      The schema definition of the classes
   │  objectClass: inetOrgPerson                 ←───┤      of an entry defines what kind of
   │  objectClass: organizationalPerson          ←───┤      object the entry may represent
   │  objectClass: person                        ←───┤      (e.g. person, org, domain,...)
   │  objectClass: top                           ←───┘      The object class definitions also
   ├─ UUID: 3ff91489-7d7e-4cdf-884e-f04753d2e6fa            define the list of attributes that
   │                                                        - must contain values
   └─ DN may change over the lifetime of the entry          - may  contain values.
      for instance, when entries are moved within a tree.
      An UUID attribute might be provided in the set of
      the entry's operational attributes to really have
      a Unique ID associated to the entry
      - 'dn' is neither an attribute nor a part of the entry.

      Note: dc stands for (D)omain (C)omponent

- A server holds:
  - a subtree starting from a specific entry*
    For example: "dc=example,dc=com"
  - (optional) references to other servers
    an attempt to access a dn in other server will
    return a server-referral to the client.
    - (optional) some servers support chaining:
      - The server will directly contact the other
        servers on behalf of the client

- LDAP rarely defines any orderin
 (sets need not be ordered)

BIND also sets the LDAP protocol version by sending a

When LDAP servers are in a replicated topology, LDAP clients should consider using the post-read control to verify updates instead of a search after an update.

 URI scheme
ldap://host:port/"Distinguished Name"?csv_list_attributes?search_scope?filter?extensions
                  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^ ^^^^^
                  Used as search base    comma-separated  search
                                         list of attr     scope:
                                         to retrieve    - base DN
                                                        - one (level)
                                                        - sub (tree)

 Directory Schema
- set of rules (definitions and constraints) concerning
  the structure of the directory information tree (DIT),
  or what information the server can hold.
  - Attribute Syntaxes: Provide info about the kind of info that can be stored in an attribute.
  - Matching Rules    : Provide information about how to make comparisons against attribute values.
  - Matching Rule Uses: Indicate which attribute types may be used in conjunction
                        with a particular matching rule.
  - Attribute Types   : Define an object identifier (OID) and a set of names that may be
                        used to refer to a given attribute, and associates that attribute with a
                        syntax and set of matching rules.
  - Object Classes    : Define named collections of attributes and classify them into sets of
                        required and optional attributes.
                        ObjectClasses can be inherited.
  - Name Forms        : Define rules for the set of attributes that should be included in the
                        RDN for an entry.
  - Content Rules     : Define additional constraints about the object classes and attributes
                        that may be used in conjunction with an entry.
  - Structure Rule    : Define rules that govern the kinds of subordinate entries that a given
                        entry may have.

  NOTE : Clients may learn about the schema elements that the server supports
         by retrieving an appropriate subschema subentry.

- A schema for representing individual people within organizations is termed a white pages schema.

 Access control is not standardized   though there are commonly used models.

 LDAP extension point
  - define new operations.
  - modify requests/responses (sort results,...)
  - New search scopes and Bind methods can be defined.
  - new attributes options modifying their semantics.
  - ...

 Access protocol
- As LDAP has gained momentum, vendors have provided it
   as an access protocol to other services
  For example, Unix user and group information (via PAM, NSS modules)
- LDAP is often used by other services for authentication.

 Usage
- two common styles of naming:
  - top level objects are the c= (country) object
    Ex:
                    l=Locality, ou=Some Organizational Unit, o=Some Organization,        c=FR
    cn=Common Name, l=Locality, ou=Some Organizational Unit, o=Some Organization, st=CA, c=US

  - top level objects are domains
    Ex:
    cn=Common Name, dc=example,  dc=com

- See also:
- ldapsearch:  CLI utility for querying an LDAP directory.
@[https://github.com/tldr-pages/tldr/blob/master/pages/common/ldapsearch.md]
[[}]]

## Active Directory: [[{use_case.AAA.activeDirectory,protocol.kerberos,protocol.ldap]]
Active Directory LDAP requires that names of directory objects be
formed according to RFC 1779 and RFC 2247:
- @[https://www.ietf.org/rfc/rfc2247.txt]
    This document defines an algorithm by which a name registered with
    the Internet DNS can be represented as an LDAP distinguished name.

    subdomain.com  ←→  dc=subdomain,dc=com

    The algorithm for transforming a domain name is to begin with an
    empty distinguished name (DN) and then attach Relative Distinguished
    Names (RDNs) for each component of the domain, most significant (e.g.
    rightmost) first. Each of these RDNs is a single AttributeTypeAndValue,
    where  the type is the attribute "DC"  and
           the value is an IA5 string containing the domain name component

    Two LDAP object classes are also defined.
    - dcObject: to integrate into alreaded existing schemas,
                alowing the dc attribute to be present in an entry.
    -   domain: structural object class used for entries in which no
                other information is being stored

- @[https://www.ietf.org/rfc/rfc1779.txt]
    X.500/LDAP distinguished names (primary keys) are encoded in ASN.1.
    there is a need to have a user-oriented string representation of DNs.
    ("human to human")

    Standardised Keywords*             Exs:
    Key     Attribute (X.520 keys)     |CN=Christian Huitema, O=INRIA, C=FR
    ------------------------------     |CN=Christian Huitema; O=INRIA; C=FR
    CN      CommonName                 |<CN=Christian Huitema; O=INRIA; C=FR>
    L       LocalityName
    ST      StateOrProvinceName        |CN=James Hacker,
    O       OrganizationName           |L=Basingstoke,
    OU      OrganizationalUnitName     |O=Widget Inc,
    C       CountryName                |C=GB
    STREET  StreetAddress
                                       |OU=Sales + CN=J. Smith, O=Widget Inc., C=US
                                          |CN=L. Eagle, O="Sue, Grabbit and Runn", C=GB
                                          |CN=L. Eagle, O=Sue\, Grabbit and Runn, C=GB
[[}]]
[[}]]
# ─────────────────────────────────────────────────────────────────────────
# Amazon Cognito User Pools [[{]]
https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html
[[}]]

## Who is who[[{]]
https://www.researchgate.net/scientific-contributions/Ben-Fisch-2124481134
[[}]]

## Encrypted fs: tldr/gocryptfs.md at main · tldr-pages/tldr · GitHub [[{]]
https://github.com/tldr-pages/tldr/blob/main/pages/common/gocryptfs.md
[[}]]

##  hashicorp-cloud-vault-beta [[{]]
https://www.infoq.com/news/2021/01/hashicorp-cloud-vault-beta/
[[}]]

## Themis Crytpo library [[{]]

https://github.com/cossacklabs/themis
Cross-platform library for secure data storage, message exchange,
socket connections, and authentication
One cryptographic library that fits them all: Themis is the best fit
for multi-platform apps (e.g., iOS+Android+Electron app with Node.js
backend) because it provides 100% compatible API and works in the
same way across all supported platforms.
- used for example by https://github.com/cossacklabs/pg_themis
  PostgreSQL (9.1+) extension for data encryption.
[[}]]


## Rekor: Immutable Ledger for Soft. Artifacts [[{blockchain,software,qa.blockchain,01_PM.backlog]]
@[https://github.com/sigstore/rekor]
- Allow soft.maintainers record signed metadata to tamper resistant immutable record.
- CLI application + RESTFul API for validation and a transparency log for storage.
[[}]]

## Indistinguishability obfuscation [[{]]
https://en.wikipedia.org/wiki/Indistinguishability_obfuscation
[[}]]

## Cryptography: « Il suffit d'un laser et d'un peu d'optique pour que le monde de l'information change de paradigme » | larecherche.fr
https://www.larecherche.fr/cryptographie-photonique-optique/%C2%AB-il-suffit-dun-laser-et-dun-peu-doptique-pour-que-le-monde-de

Une collaboration internationale impliquant la chaire photonique au sein du laboratoire LMOPS de CentraleSupélec et de l’université de Lorraine (Metz), l’université de Yale (États-Unis), Trinity College Dublin (Irlande), Imperial College London (Royaume-Uni), et Nanyang Technological University (Singapour), a mis au point un laser générant plus de 250 trillions (250 milliards de milliards) de nombres aléatoires par seconde. Un résultat majeur, alors que le précédent record était de 560 milliards de nombres aléatoires en 2014, déjà détenu par la chaire photonique. Marc Sciamanna, enseignant chercheur à CentraleSupélec, nous explique les enjeux d'un tel record.

2017 @[https://patents.google.com/patent/US9634836]
TODO: Classify all related to use_case.signature.aggregated


