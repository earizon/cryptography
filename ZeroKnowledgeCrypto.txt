[[{]]
# Zero Knowledge Cryptography

## ZKP Introduction [[{101,crypt.zk,use_case.privacy,PM.TODO]]
* Extracted from <https://nakamoto.com/cambrian-explosion-of-crypto-proofs/><br/>
  """ ... we are currently experiencing a Cambrian Explosion in the field
  of cryptographic proofs of computational integrity (CI), **a subset of
  which include zero-knowledge proofs**. 
   ...1-3 new systems a year a couple of years ago,
   ...1-3 weekly/monthly today.
  """

- Brief summary from:
  * <https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/>
  * <https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/>
WARN: Original source contains many more interesting and important info.

- zero knowledge proof actors (probabilistic Turing machines in practice):
  - Prover  : works to generate a proof about some mathematical
              statement being true:  e.g. a given graph possesses a three-coloring.
  - Verifier: Verifies the proof through a well known and public
              (interactive/non-interactive) protocol/procedure.

- The proof generated by the prover must have next properties:
  - Completeness: An honest Prover will eventually convince (any) Verifier.
  - Soundness   : Prover can only convince Verifier if statement is true.
  - Zero-knowledge(ness): Verifier learns no information other than statement is true.
- General ZKP impose "lot of computing effort" on Prover, but not in verifier.
- Signature is a particula use-case of ZKP. The verifier can only probe
  to know the signature key without revealing it,  but signer (prover)
  can not probe ARBITRARY YES/NO statements.
- (Claus-Peter) Schnorr identification proof-of-knowledge protocol:
  It forms the basis of many of our modern signature schemes even if author
  was concerned with identity, not signature.

## PRE-SETUP)

1. Alice has published her public key to the world.
  ```
  p : public "big" prime number defining the space of integers we 
      will move on, defining the "MAIN NUMBER SET".
  g(enerator) and q:  Public constants in protocol defining the 
  "VERIFICATION NUMBER SUBSET" such as (g¹,g², ... g^q) form a
  cyclic group of prime-order q (7 in draw)
                                 └──┬─────┘
                                    └──────────────┐
     a = 5, private (exponent) key ┐               v  
   |··g¹·····g²·····g³·····g⁴·····g⁵······g⁶······g⁷···| 
   ^  ^                           └┴ pub.key           ^
   0  generator: Public constant     PK_A mod p.       p
       param in protocol.            Nobody can fetch g from PK_A 
      g^q == 1                       since we are working in a 
                                     mod-p group. (or so we think)
  ```

## PROTOCOL-Execution

* probe to Bob (Verifier) knowledge of private key `g` corresponding 
  to the public key without revealing any information.

  ```
  | participant "Alice (prober)" as P
  | participant "Bob (Verifier)" as V
  |
  | P -> P : k = random[1,q] , i.e: Some random k in the VERIFICATION SUBSET 
  |
  |                                      ┌ k
  |              ··g¹·····g²·····g³·····g⁴·····g⁵······g⁶······g⁷···
  | P -> V : h = g^k mod p              └┴ h
  | V -> P : c = random[1,q] 
  |                        ┌ c(hallenge)
  |              ··g¹·····g²·····g³·····g⁴·····g⁵······g⁶······g⁷···
  |                      Replace by HashOf( g^k || M ) for non-interactive mode *³
  | P -> V : s = ( a·c + k ) mod q *¹, *²
  |                       
  | V -> V : Check ¿ ( PK_A^c  ·   h ) mod p == g^s ?
  |                    ^^^^        ^
  |                     ==         == 
  |                   g^a mod p    g^k mod p
  |                  ( (g^a)^c · g^k ) mod p
  |                       └─┬┘ └┬──┘
  |                        ┌┴┐ ┌┴┐
  |                    ( g^a·c + k ) mod p
  |
  | *¹: Easy to calculate for P since it knows secret k.
  |     k, a, c are all in "mod q namespace" (using "IT parlance")
  |     PK_A, h are in the "mod p namespace"
  |     WARN: mod q, not p.

  | *²: WARN: if "Extractor" can trick P into REUSING THE SAME RANDOM K
  |     then he can solve the following simple equation to recover `g` (Prover's) secret:
  |     RUN 1) challenge s1 = a·c1 + k  mod q
  |     RUN 2) challenge s2 = a·c2 + k  mod q
  |      ==                s1 - s2  / (c1 - c2) mod q
  |      == (a·c1 + k) - (a·c2 + k) / (c1 - c2) mod q
  |      ==            a·( c1 - c2) / (c1 - c2) mod q
  |      ==            a                        mod q
  |      ==            a
  |
  |     REAL ATTACK ON SYSTEMS WITH BAD RANDOM NUMBER GENERATORS. [[{101}]]
  |
  | *³: M is an optional arbitary message string.
  |     The method also can be used as signature schema since only
  |     secret holder can produce a signature.
  |     The resulting protocol is called SCHNORR SIGNATURE SCHEME,
  |     and it's the BASIS OF PROTOCOLS LIKE EdDSA.
  ```

## ZKP compared
- While other privacy techniques like bulletproofs, ring
  signatures and stealth addresses, etc. mask the identities of the
  entities involved in a business transaction, ZKP techniques allow to
  prove logical statements without divulging any information and yet
  proving the validity of such proofs.


## zk-SNARK
  "(Z)ero(K)nowledge(S)uccinct(N)onInter(A)ctive A(r)gument of (K)nowledge"
  Succinct == Low resources needed on prober / verifier.
- zk-SNARK convert logical statements to arithmetic circuits,
  that are then leveraged to generate proofs.

## Zksnarks and crypto accumulators [[{PM.TODO,use_case.privacy]]
https://blog.coinbase.com/zksnarks-and-cryptographic-accumulators-f840da0b61c6
[[}]]


## zk-Stark
- Improves over zk-SNARK by not requiring a trusted pre-setup.
- Transparent: public randomness, no "trusted setup"
- Argument of Knowledge
- post-quantum secure.
- C&P From: <https://www.youtube.com/watch?v=_6TqUNVLChc>

  ```
  |                    Proof Size    Prover   Verif.
  |                                  Time       Time
  | SNARKs ¹            288 bytes    2.3s       10ms
  | STARKs              45KB-200KB   1.6s       16ms
  | Bulletproofs            ~1.3KB   30s       1100ms
  | ¹: plus trusted setup
  ```

Implementations:
- SNARKs:
  - Zokrates: DSL to generate proofs and validate them on Ethereum
  - Bellman: Rust implementation
  - Snarky: OCalm implementation (DSL)
  - Libsnark: C++
  - Iden3's Circum (DLS) + SnarkJS js implementation
  - Republic Protocol's zksnark.rs (DSL) Rust impl.
  - DIZK java distributed system
- STARKs: Go/C++ implementation
- Bulletproofs: Ristretto Rust imple. with GREAT documentation

## External Links:
- Awesome ZKP: <https://github.com/matter-labs/awesome-zero-knowledge-proofPurpose>
- Tjaden Hess Github: <https://github.com/tjade273?tab=repositories&q=&type=source&language=>
[[}]]

[[}]]


