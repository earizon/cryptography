## Apropos
   Cryptography notes
   Content is versioned in git.  commits, issues and pull-requests welcome!
<https://www.github.com/earizon/cryptography>

Source Git: <https://github.com/earizon/cryptography>
HTML view : <https://earizon.github.io/txt_world_domination/viewer.html?payload=../cryptography/notes.txt>

## TOPIC Acronyms
  _PM    : Project Management
  101    : Core concepts
  qa     : Quality Assurance
  qa.UX  : QA User Experience

## External Links [[{]]
* <https://en.wikipedia.org/wiki/Index_of_cryptography_articles>
* <https://cryptography.io/en/latest/>
* <https://crypto.stackexchange.com>
* <https://www.rsaconference.com/>
* <https://iancoleman.io/>JS Tools for:
   * BIP39 Mnemonic Code Converter
   * Blockchain Blocksize/SAFE Network Attack/...
   * Group Size Calculator
   *  Cost Benefit Calculator
   * Multisig Tool
   * ...
-<https://keccak.team/index.html>
  information about our different cryptographic schemes and constructions,
  their specifications, cryptanalysis on them, the ongoing contests and the
  related scientific papers.
- Outline of Cryptography at Wikipedia:
<https://en.wikipedia.org/wiki/Outline_of_cryptography>
- Ronald L.Rivest List of Links!!!
<http://people.csail.mit.edu/rivest/crypto-security.html>
- Kevin McCurley's links:
<http://www.swcp.com/~mccurley/cryptographers/cryptographers.html>
- University of Southern California (Information Sciences Institute;
  Global Operating Systems Technology (GOST) Group)
<http://nii.isi.edu/gost-group/>
- Rootshell.be articles on exploits, security alerts, ...:
<http://https://blog.rootshell.be/>
- Electronic Colloquium on Computational Complexity:
<https://eccc.weizmann.ac.il/>
- ACM Special Interest Group on Security, Audit and Control (SIGSAC):
<http://www.sigsac.org/>
- NSA Playset (OOSS ANT catalog):
<https://en.wikipedia.org/wiki/NSA_Playset>
- Cryptology ePrint Archive:
  <https://eprint.iacr.org/>
  * rapid access to recent research in cryptology.
  * Papers have been placed here by the authors and did
    not undergo any refereeing process other than verifying
    that the work seems to be within the scope of cryptology
    and meets some minimal acceptance criteria and publishing
    conditions.
* SCIPR Lab:
<http://www.scipr-lab.org/>
<https://github.com/scipr-lab>
  multi-institutional academic collaboration of researchers
  seeking to bring to practice cryptographic proof systems that
  provide succinct integrity and privacy.

### External Links on Number Theory
* <http://numbertheory.org>
- [Number Theory and its History](https://archive.org/stream/NumberTheoryItsHistory/Ore-NumberTheoryItsHistory)
- The Prime Pages <http://primes.utm.edu>
- [NTL](http://www.shoup.net/ntl): A Library for Doing Number Theory

## Bibliography/Books
* Crypto101
  <https://www.crypto101.io/>
* Real-World Cryptography: by ... 2021 (Maning)
* Encyclopedia of Cryptography and Security
  <https://www.springer.com/us/book/9781441959058>
* Handbook of Applied Cryptography, by Menezes, van Oorschot, and Vanstone.
  <http://www.cacr.math.uwaterloo.ca/hac/>
* Intro to Crypto.
<https://www.cs.umd.edu/~waa/414-F11/IntroToCrypto.pdf>
 <https://en.wikipedia.org/wiki/List_of_important_publications_in_cryptography>
* "Applied Cryptography", Bruce Schneier, ISBN 0-471-11709-9, 1993
* <https://cryptobook.nakov.com/>
  [github link](https://github.com/nakov/Practical-Cryptography-for-Developers-Book)
  modern practical book on cryptography for developers with code examples,
  covering core concepts like hashes (like SHA-3 and BLAKE2), MAC codes
  (HMAC,GMAC, ...), key derivation functions (like Scrypt, Argon2), key
  agreement protocols (like DHKE, ECDH), symmetric ciphers (AES, ChaCha20,
  cipher block modes, authenticated encryption, AEAD, AES-GCM,
  ChaCha20-Poly1305), asymmetric ciphers and public-key cryptosystems
  (RSA, ECC, ECIES), elliptic curve cryptography (ECC, secp256k1, curve25519),
  digital signatures (ECDSA and EdDSA), secure random numbers (PRNG, CSRNG)
  and quantum-safe cryptography, along with crypto libraries and developer tools,
  with a lots of code examples in Python and other languages.
[[}]]

## Conferences and Groups
* 2012: Kenny Paterson and Nigel Smart started an annual conference
        called Real World Crypto.



# Cryptography 101 [[{101]]

* ☞ Doing encryption right is tough, MANAGING SECRETS IS EVEN HARDER!!! ☜[[{doc_has.key-point}]]
* PERFECT SECRECY: refers to a cryptosystem whose security derives purely
  from INFORMATION THEORY => It cannot be broken even with unlimited resources
  (unless the secret is exposed).
  * There is NOT enough information to break the encryption.
    cryptosystems are considered cryptanalytically-unbreakable.
  * This mostly correspond to "symmetric" encryption schemas.
<https://en.wikipedia.org/wiki/Information-theoretic_security>

- (PERFECT) FORWARD SECRECY ensures that session (temporal/on-demand) keys
  will not be compromised even if the private key of the server is compromised.
  Forward secrecy protects past sessions against future compromises of secret
  keys or passwords.
  WARN: Simple symetric encryption schemas are NOT forward secrecy compliant,
        and a compromised keys can reveal past encrypted-communications.
<https://en.wikipedia.org/wiki/Forward_secrecy>

- SECRET SHARING: refers to methods for distributing a secret amongst a group
  of participants, each of whom is allocated a share of the secret.
  The secret can be reconstructed only when a sufficient number, of possibly
  different types, of shares are combined together; individual shares are of
  no use on their own.
<https://en.wikipedia.org/wiki/Secret_sharing>

- AVALANCHE EFFECT: desirable property of cryptographic algorithms,
  typically block ciphers and cryptographic hash functions, wherein if an
  input is changed slightly (for example, flipping a single bit), the output
  changes significantly.
<https://en.wikipedia.org/wiki/Avalanche_effect>

- Cryptographic Primitive: Informal term. Conceptually, it is the smallest
  useful construction we can have in cryptography. The term appears
  frequently in text books.
- Cryptographic Protocol: Construction based in cryptographic primitives
  in order to build a protocol.

- MALLEABILITY:
  - An (often) UNdesirable property of some cryptographic algorithms.
  - An encryption algorithm is "malleable" if it is possible to transform
    a ciphertext into another ciphertext which decrypts to a related plaintext.
<https://en.wikipedia.org/wiki/Malleability_(cryptography)>

- SPONGE FUNCTION (OR SPONGE CONSTRUCTION):
  algorithms with finite internal state taking an input bit stream
  of any length and producing an output bit stream of desired length.
  Used to model and implement many cryptographic primitives, including
  cryptographic hashes, message authentication codes, mask generation
  functions, stream ciphers, pseudo-random number generators, and
  authenticated encryption.
<https://en.wikipedia.org/wiki/Sponge_function>

- BRUTE FORCE ATTACKS:
<https://twitter.com/fermatslibrary/status/969935429712666625>
  According to the second law of thermodynamics, the minimum amount
  of energy required to record a single bit by changing the state
  of a system is:

  K x T  (Boltzman-Constant "times" temperature-of-the-system)

  Assuming an ideal computer running at 3.2ºK (The temperature
  of the cosmic background radiation), a bit change would consume
  4.4 x 10^-16 erg.
  - Annual energy output of the Sun: 1.21 x 10^41 Erg, enough to
    power 2.7 x 10^56 single bit changes, or enough to put a
    187-bit counter through all its values.
  - To run through a 256-bit key we would need to build Dyson spheres
    and capture the energy of:
    2^69 = 5.9 x 10^20 Suns during a year!!!

- RANDOM NUMBER GENERATORS TYPES: [[{crypt_asymmetric.rsa,protocol.TLS]]
  - True random number generators(quantum, thermal, oscillators,...)
  - Cryptographically secure pseudorandom generators
    (Unix /dev/urandom, Windows CryptGenRandom,...)
  - Pseudo-random number generators.

  WARN: Wrong Random number generation can break many systems. Example:
  <https://www.infoq.com/news/2019/12/rsa-iot-vulnerability/>
  !!!!Poor Random Number Generation Makes 1 in every
      172 RSA Certificates Vulnerable!!!! ← !!!!
  [[}]]
[[}]]

# Symmetric Cryptography

## Symmetric primitives [[{101]]

* Diagram summary:
  ```
  | Peer 1                              Peer 2
  | Plain > |Encrypt|> C1 > |Decrypt| > Plain
  |             ^                ^
  |             └─ KEY("Secret") ┘
  |             SHARED BY PEER 1 AND 2
  ```

NOTE: In symmetric cryptography the key is often refered with
the name of **"PASSWORD" to distinguish from  
"PRIVATE KEY" used in asymmetric cryptographic schemas**.
[[{02_doc_has.comparative}]]

Symmetric crypto. broadly splits in two categories:

* SYMMETRIC STREAM CIPHERS:          [[{crypt_symmetric.stream_cipher]]
  * inputs of "any lenght". Very difficult to implement properly.
  * Implementations: ChaCha, ...
  * ``` 
    |  INPUT          KEYSTREAM
    |                 GENERATOR
    |  ----------     ---------
    |  KEY, NONCE ···············> K0, K1, ...  ┐
    |                                           ├·> XOR ·> C0, C1, ...
    |  MESSAGE    ···············> M0, M1, ...  ┘
    ``` 
  * **"BUTS"**
    Generating a safe (non predictive) KEY for the stream cipher is "difficult"
[[}]]

* BLOCK  CIPHER:                    [[{crypt_symmetric.block_cipher]]
  * inputs must be divided into chunks of same size.
  * Hide plaintext transformation to ciphertext through:
    * confusion : mapping input to output hard to predict (not linear and parts of keys)
    * diffusion : permutate bits
  * Most block ciphers are based on SP-Networks composed of:
    * Subtitution box : "map<byte, byte>"   (replace bytes with bytes )
    * Permutation box :  moves bits around.
    * Some substitution plus permutation are combined into a single round.
    * Rounds are then repeated enough times to ensure the algorithm is secure
    * SP-Networks alone are not enought. An extra  (secret)KEY  is used like:
      ```
      |                  ROUND1                ROUND2       ...    
      |                                                            
      | Plain > XOR > │Subsitution│ > XOR > │Subsitution│ > ... > C
      |         KEY   │Permutation│   KEY   │Permutation│           
      ```
  * Block ciphers have one or more block size(s), but during transformation
    the block size is always fixed.
  * Block cipher operation modes:
    * A block cipher alone can only encrypt a single block of N-bits.
    * The operation mode describes how to repeatedly apply a
      cipher's single-block operation to securely transform N blocks.
    * Most modes require an initialization vector (IV) for each new encrypt.  [[crypt_symmetric.IV]]<br/>
      **IV must be non-repeating and, for some modes, random as well.
        and unpredictable => Difficult to generate (vs Nonce).**              [[02_doc_has.comparative]]
      * KEYPOINT: IV ENSURE DISTINCT CIPHERTEXTS ARE PRODUCED EVEN FOR THE SAME PLAINTEXT.
        WHEN REUSING THE SAME PASSWORD.

Operation modes include:
* ELECTRONIC CODE BLOCK (ECB): 
  WARN: Deprecated. Don't use it, if different messages share 
  same data information data leaks cans rise
   ```
   | M1 > |E_k| > C1 |
   | M2 > |E_k| > C2 |
   | M3 > |E_k| > C3 |
   ```
* CIPHER BLOCK CHAINING (CBC): <- "BUTs":
  1. NOT PARALELIZABLE.
  1. can not seek randomnly
  1. Needs an UNPREDICTABLE IV
  ```
  |IMPUT                            
  |_____                            
  |IV                               
  |M1    > |XOR(IV)| > |E_k| > C1
  |      > |XOR(M2)| > |E_k| > C2
  |      > |XOR(M3)| > C3
  ```
* COUNTER MODE (CT):  (Can be paralellized)
  ```
  |Nonce + 0 > |E_k| > XOR(M1) > C1  ← Noces are used once         [[crypt.nonce]]
  |Nonce + 1 > |E_k| > XOR(M2) > C2
  |Nonce + 2 > |E_k| > XOR(M3) > C3
      ```

* BLOCK CHIPER "BUTS":
  * block chipers require Padding when the message does NOT exactly
    match a multiple of key size. This can introduce security bugs if not
    implemented properly.<br/>
   <https://en.wikipedia.org/wiki/Padding_(cryptography)>
    (There are block chiper operation modes that do NOT require padding
     because they effectively use a block cipher as a stream cipher).
  [[}]]
[[}]]

## AES [[{101,crypt_symmetric.aes,use_case.encryption]]
* used by "almost every block cipher" 
* Supersedes DES(2002 Standard)[[crypt_symmetric.des,02_doc_has.comparative]]
* Built around Rijndael (SP-Network with 128bit block size) with 
  128|192|256 bits keys.
* Round count depends on key lenght: 10|12|14 cycles
* For each Round: SubBytes -> ShiftRows -> MixColumns
* Modern CPUs have hardware instruccions to accelerate AES computation.<br/>
  REF: study of AES-NI acceleration using (Libre|Open)SSL, 2018-11-08
  <https://calomel.org/aesni_ssl_performance.html>
  * AES-NI x86-extension **MUST BE ENABLED THROUGH THE BIOS** [[01_PM.troubleshoot]]
    ```
    |$ cat /proc/cpuinfo | grep flags <·· Checking AES-NI enabled on linux
    | flags: fpu vme ... aes  ... arat
    ```
  * Only supported by real CPU cores - vs hyper-threaded/Virtual cores -
  * LibreSSL 2.5.0 ( ~ OpenSSL 1.0.2d) ; FreeBSD 11 ; Clang LLVM compiler
    8192 byte blocks
    Script used for testing:
    ```
    $ openssl speed -elapsed -evp chacha
    $ openssl speed -elapsed -evp aes-128-gcm
    $ openssl speed -elapsed -evp aes-256-gcm
    $ openssl speed -elapsed -evp aes-128-cbc
    $ openssl speed -elapsed -evp aes-256-cbc
    ```
    Results: (ChaCha20 256 bit stream cipher,NOT accelerated used as 
    reference/baseline)
    ```
    | AES Performance per-CPU-core for TLS v1.2 Ciphers
    | (Note, Google opts for ChaCha20 for low-powered devices )
    |
    |                       ┌······························· ChaCha20
    |                       ·    ┌··························· AES-128-GCM
    |                       ·    ·    ┌······················ AES-256-GCM
    |                       ·    ·    ·    ┌··············· AES-128-CBC
    |                       ·    ·    ·    ·    ┌··········· AES-256-CBC
    │                       ·    ·    ·    ·    ·    ┌···· Total Score
    │                       v    v    v    v    v    v
    | AMD Ryzen 7 1800X   573 3006 2642 1513 1101  = 8835
    | Intel W-2125        565 2808 2426 1698 1235  = 8732
    | Intel i7-6700       585 2607 2251 1561 1131  = 8135
    | AMD FX 8350         367 1453 1278  716  514  = 4328
    | AMD FX 8150         347 1441 1273  716  515  = 4292
    | Intel E5-2650 v4    404 1479 1286  652  468  = 4289
    | Intel i5-2500K      358 1274 1140  728  522  = 4022
    | Intel Xeon E5-2630  247  962  864  541  394  = 3008
    | Intel Xeon L5630    225  701  610  626  450  = 2612
    | Intel ATOM D525      98   51   43   28   20  =  240
    | Snapdragon S4 Pro*1 131   41    -    -    -  =  172
    | ARM Cortex A9    *1  73   24    -    -    -  =   97
    | 
    | *1: Snapdragon and ARM Cortex values reported by Google Developers
    ```
    How do I interpret the results? Let's suppose:
    * connection bandwidth: 10 Gbs (=1,250MBs)
    * Web server is able to concurrently encrypt|decrypt
      data to saturate the 10 gigabit connection.
    * Suppose 100% of our clients use AES-128-GCM cipher
    * we need at least two CPU cores: one to recieve/decrypt and one for encrypting/send
    * IDEALLY each CPU must be able to sustain 10Gbs/1,250MBs of AES encrypted data/cpu-core.
    * From previous performance-table, just "AMD Opteron 6380" and  faster ones will be able
      to keep to pace.
      (Note: Opteron-6380 has 16 cores, so it leaves many other CPU cores for network I/O,
       firewall rules, ...)

REAL-WORLD ...
* Clients connect with a variety of ciphers.
* System is not dedicated to just cipher processing.
* Some ciphers can be paralellized in multiple cpu-cores
  e.g: "Intel Xeon L5630" 4-cores can process up to 701 MB/s AES-128-GCM data (2,804 MBs)
  (enough for en/de-crypting data on a 10 gigabit link using AES-128-GCM)

[[{crypt_oneway.hash,101,use_case.data_integrity,use_case.proof-of-existence]]
# Hash (Oneway) Primitives 

  ```
  |             ···· computationally feaseable ······>
  |             <··· computationally non-feaseable ···
  |
  | Small/Big input ····> | Hash Function | ····> Hash Result
  | (preimage)
  ```

- A single bit change in "Plain" input causes a completely
  different Hash Result. ("avalanche effect").
- There are infinite inputs for each possible hash output.
  Still, given a single hash output, it's extremnly difficult to
  find any of the infinite plain inputs (without previous knowledge)
- Used to validate input integrity (input has not been modified).
- Frequently combined with symmetric/asymmetric primitives.
- Cryptographic Hash function desired security properties:
  * preimage resistance: It must be imposible to reverse the hash to
    recover the input. ("one-way computation")
  * collision resistance: No one should be able to produce two different inputs
    that hash to the same output.
  * second pre-image resistance: it must be imposible to find a different input
    that hashes to the same digest.
    (similar to collision resitance, but in this case we have information
     about a first input)

### Math 101 "Birthday bound": (Probability theory)
* **Q** : _How many people in a room are needed to find, at least with a
     50% of chance, two people sharing the same birthday_?<br/>
  **A** : 23 people on average!!!<br/>
  IN GENERAL, IF WE RANDOMLY GENERATE STRINGS FROM A SPACE OF 2^n 
  POSSIBILITIES, WE CAN EXPECTE A 50% CHANCE THAT SOMEONE WILL FIND A
  COLLISION AFTER HAVING GENERATED APPROXIMATELY 2^(n/2) STRINGS.
  ```
  | eg: IN A 2²⁵⁶ SPACE, WE NEED TO GENERATE 2¹²⁸ HASHES =>
  |     We need 128 bits for pre-image&second-preimage
  |     resistance and 256 bits for collision-resistance.
  ```
* Hash functions take messages of any lenght, and returns a
  pseudo-ramdom hash of fixed length.
  ```
  | ┌··· Loop <··┐
  | ·            ·
  | Block of   Current ··> Final
  | message     Hash       Hash
  | ·            ·
  | └··> Loop ···┘
  ```
* HMAC: An attacker doesn't know the shared KEY so he can not add
  the correct HASH.
  ```
  | PlainText ···> |symmetric(KEY)| ···> CipherText
  ```
### CipherText + HASH(KEY+CipherText)

* **Q**. Why the "5381"/"33"/... constant in hash?
  [REF@stackoverflow](https://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function)<br/>
  **A**. """ 5381 is just a number that, in testing, resulted in
  [fewer collisions](http://en.wikipedia.org/wiki/Collision_%28computer_science%29) and
  [better avalanching](http://en.wikipedia.org/wiki/Avalanche_effect).
  You'll find "magic constants" in just about every hash algorithm.

## SHA-3 
* Subset of [Keccak](https://en.wikipedia.org/wiki/SHA-3)

## BLAKE3:   
* Extremely Fast+Parallelizable Crypto.Hash
* [REF@InfoQ](https://www.infoq.com/news/2020/01/blake3-fast-crypto-hash/)
  """ BLAKE3 is the most recent evolution of the BLAKE cryptographic hash
    function. Created by Jack O'Connor, Jean-Philippe Aumasson, Samuel
    Neves, and Zooko Wilcox-O'Hearn, BLAKE3 combines general purpose
    cryptographic tree hash bao with BLAKE2 to provide a big performance
    improvement over SHA-1, SHA-2, SHA-3, and BLAKE2. """ [[{crypt.performance}]]
[[crypt_oneway.hash}]]

# Message Authentication
[[{101,crypt_symmetric,crypt_oneway.hash,use_case.AAA,use_case.data_integrity]]

## HMAC Authentication (sym.encrypt + hash)
- PRESETUP: A shared symmetric key must have been pre-deployed on both peers.
- HMAC stands for (H)ashed (M)essage (A)uthentication (C)ode "symmetric encryption"
- HMAC allows for authentication of signer of a "frozen" message (file/email/...).
  (vs authentication in temporal session establishment in network protocol)
  Verifier must own also the same password/secret-key used by HMAC "prover".
  Identity principal == "owner of private key".
  ```
  | INPUT                      OUTPUT                        STEP 1)
  | -----                      ------
  | secret key ···(derive) ··> inner key
  |                            outer key
  | INPUT                                          OUTPUT    STEP 2)
  | -----                                          ------
  | msg  > sym.cypher > hash > sym.cypher > hash > HMAC
  |        inner key           outer key
  |        └───┬───┘           └───┬───┘
  |  The algorithm provides better immunity against length extension attacks:
  |  "with most hash functions, it is easy to append data to the message
  |   without knowing the key and obtain another valid MAC".
  |  (length extension collision malleability).
  |  More info at <https://en.wikipedia.org/wiki/HMAC>.
  ```
   With HMAC, because the outer application of the hash function masks the
   intermediate result of the internal hash. The values of ipad and opad are
   not critical to the security of the algorithm, but were defined in such
   a way to have a large Hamming distance from each other and so the inner
   and outer keys will have fewer bits in common.
[[}]]

## Authenticated Encryption with associated data(AEAD) [[{use_case.data_integrity,01_PM.TODO]]
<https://en.wikipedia.org/wiki/Authenticated_encryption>
- The need for AE emerged from the observation that securely combining
   separate confidentiality and authentication block cipher operation modes
   could be error prone and difficult confirmed by a number of practical
   attacks introduced into production protocols and applications by
   incorrect implementation, or lack, of authentication (including SSL/TLS)

- A typical programming interface for AE mode implementation would provide the following functions:

 Encryption
     Input : plaintext, key, and optionally a header in plaintext that will not
             be encrypted, but will be covered by authenticity protection.
     Output: ciphertext and authentication tag (message authentication code).
 Decryption
     Input : ciphertext, key, authentication tag, and optionally a header.
     Output: plaintext, or an error if the authentication tag does not match
             the supplied ciphertext or header.

- Approaches to authenticated encryption:
  - Encrypt-then-MAC (EtM)
  - Encrypt-and-MAC (E-and-M)
  - MAC-then-Encrypt (MtE)
  [[}]]

[[{101,secret_mng.key_exchange,use_case.remote_session_establishment]]
[[ crypt_asymmetric,]]
## DIFFIE-HELLMAN(and Merkle) KEY "EXCHANGE"
- two non-local parties can jointly agree a shared secret over an insecure channel
- DH-KEX (Key exchange) UNDERPINS ALMOST EVERY ASPECT OF OUR MODERN LIVES!
- DH security is based first on "very big numbers" (~4096 bits).
- KEYPOINT: Key is not actually "exchanged" but calculated by both
            parties simultaneously.
- The DH-KEX generated shared-secret is usually called the "pre-master secret"
- It's used to derive (minutes/hours) session keys through hashing for example.
- Ephemeral Mode. DH ARE NOT STORED.
[[}]]

[[{use_case.Authentication.remote]]
## Challenge-response
* cryptographic primitive
* Used mostly in communication protocols.
* Authentication server encrypts a challenge (typically a random
  number) with a public key.  The device proves it possesses a copy of
  the matching private key by providing the decrypted challenge.
[[}]]

# IVs,nonces,Salt [[{crypt_oneway.salt,101,crypt_symmetric.IV,crypt.nonce,02_doc_has.comparative]]
- Randomness of secret keys is not enough in most scenarios due to
  the attacks by replication or repeated XORs of different messages
  encoded with the same private shared-by-peers keys.
  Next elements of randomness complements to keys:

## INIT VECTOR (IV) (SYMMETRIC ENC)

<https://en.wikipedia.org/wiki/Initialization_vector>
  in symmetric encryption is used to ensure distinct ciphertexts are
  produced even when the same plaintext is encrypted multiple times
  with the same key.  IV must not be repeated, and depending on the
  scheme used must also be cryptographically random.

## SALT (ENCRYPTION, ONEWAY HASHING)

Summary from [Wikipedia](https://en.wikipedia.org/wiki/Salt_(cryptography))
* Salt: random data used as additional input to a one-way
  function that "hashes" data (ussually password).
* primary use are:
  * Offline encryption protection.
  * KEY DERIVATION FUNCTIONS:
  * DEFENSE AGAINST TABLE ATTACKS:
    If an atacker can compute/store billions of combinations
    of dictionary hashes, the salt will force to repeat the
    computation/duplicate the storage for each possible salt.
* closely related to 'nonce':
  * Nonce must not be repeated but can be predictable.
    Salts can be repeated, and also they must be
    cryptographically random.
  * Nonce protect 'network/on-fly' data against replays.
  * Salts protect 'disk/stored'    data against dict. attacks.
  * Nonce do not need to be secret. Once a "nonce" is consumed
    it is "useless", even for attackers. Salts must be secret
    (and separated from secret keys) when using for symmetric
    encryption, but can be public when used in one-way hash
    functions.

## NONCE (PROTECTION AGAINST ONLINE MESSAGE REPLAY)

<https://en.wikipedia.org/wiki/Cryptographic_nonce>
* arbitrary number that  can only be used once.
* It can be public or predictable
* issued in network protocols to protect against replay attacks:<br/>
  An attacker, for example, replays encrypted session
  message (raw data) impersonating the client hopping to
  obtain a server session token. Since the nonce has already
  been used/wasted/consumed by the original client,
  the session establishment will fail.
[[crypt_oneway.salt}]]


[[101.building_blocks}]]

[[{crypt_asymmetric.101,standards.AES,doc_has.diagram]]
# Asymmetric Encryption

* When used for encryption, 4 keys are needed for bidirectional communication.
  ```
  |- 1 Public  key (known to everyone) is used for encryption by sender   Alice
  |- 1 Private key (known to owner   ) is used for decryption by receiver Bob
  |  (and two extra keys for Bob to Alice communication)
  |
  |           PEER 1                                 PEER 2
  | ┌---------------------┐             ┌-------------------┐
  |                                                           PRESETUP:
  |                                                           -----------------------
  |   + PrivKey1                          + PrivKey2          <· Priv.Keys
  |                                                              generated randomnly
  |   + PubKey1 ·>···········─┐┌─······<- + PubKey2           <· Pub. Keys calculated
  |                           └·┐                                (easely) from Priv.Keys
  |   + PubKey2 <············<─┘└─>·····> + PubKey1           <· Pub. Keys shared
  |                                                              by mail, ...
  |          
  |          │Encrypt │··> CypherTextA ··> │Decrypt │ ··> Plain    PEER 1 -> PEER 2
  | Plain ··>│with    │                    │with    │     textA                     
  | textA    │PubKey2 │                    │PrivKey2│    
  |                                                     
  |          │Decrypt │<·· CypherTextB <·· │Encrypt │ <·· Plain    PEER 1 <- PEER 2
  | Plain <··│with    │                    │with    │     textB    ----------------
  | textB    │PrivKey1│                    │PubKey1 │              
  ```
* KEY POINT: Based on computational complexity (vs information theory).<br/>
  Calculating private keys from public keys is considered a
  computationally intractable mathematical problem (or so we think).
  WARN: Can future Quantum computers can do the computation?
  WARN: REPEATED USE OF KEYS MAKES IT EASIER TO CRACK.

* PENDING PROBLEM: How does Peer 1/2 knows that received encrypted
  message and Public-Key2/1 belongs to real PEER 2/1 (vs fake signer)?<br/>
 "SOLUTION"     : public key infrastructure (PKI).
[[crypt_asymmetric.101}]]

# Digital Signature [[{crypt_asymmetric.101,use_case.signature,doc_has.diagram]]
- It is the "simplest" example of a Zero-Knowledge cryptographic solution. (see later)
  A signer will probe to verifiers that it holds the secret key associated to
  the tuple (signed message, public key) without revealing the public key itself.

- Private key (known to owner   ) is used for signing.
- Public  key (known to everyone) is used for checking document signature.

  ```
  |PRE-SETUP: (just once)
  |             PEER 1                                PEER 2
  |   ┌·····································┐   ┌·····························┐
  |    1. Create Private Key
  |    2. Calculates (easely)  Public Key     ┌·> 4. Stores Peer1 Public-Key
  |       from the Private Key                ·
  |    3. Share the Public Key with peers   ··┘
  |
  | SIGNATURE:
  |             PEER 1
  |   ┌·····································┐
  |    Arbitrarely   ·> Hash-of
  |    large message    Message
  |    (mail, pdf, ...)   ·
  |      ┌···············─┘
  |      ·
  |      v
  |    │Sign using │ ·> Generates Public
  |    │PrivateKey1│    signature
  | SIGNATURE VERIFICATION
  |             PEER 1                                  PEER 2
  |   ┌·····································┐     ┌···························┐
  |     1. Share message and Public   ··········>  2. Validates signature
  |        signature with peer 2                      using Peer1 Public-Key
  |
  |NOTE: By using the (cryptographically secure) hash-of-message we obtain
  |     data-integrity "for free".
  ```

* PENDING PROBLEM: How does Peer 2 knows that received 
  Public-signature and Public-Key1 belongs to real PEER 1 (vs fake 
  signer)?
  (i.e, How do we Authenticate the origin of the message)
  "SOLUTION": public key infrastructure (PKI)
  ```
  | KEY-POINT
  | DIGITAL SIGNATURE PROVIDES:
  | · NON─REPUDIABILITY: Private key owner can not neglect having signed.
  | · NON─TAMPERING    : message can not be moddified by third parties
  |   ^^^^^^^^^^^^^^^^^                          ┌─────────────────┐
  |   NON─REPUDIABILITY + NON─TAMPERING PROVIDES │LEGAL VALIDITY!!!│
  |                                              └─────────────────┘
  |   SIGNATURE IS AN EVIDENCE OF SIGNER'S WILLINGNESS TO SIGN THE MESSAGE.
  ```

* **DIGITAL SIGNATURE SCHEMA** REFERS TO THE NEXT TUPLE OF ALGORITHMS:
  ```
  | 1) KEY-PAIR GENERATION ALGORITHM
  | HOW PUBLIC (VERIFICATION) KEY IS GENERATED FROM
  | PRIVATE (SIGNING) KEY.
  ```
  ```
  | 2) SIGNING ALGORITHM
  |       INPUT           ¹             OUTPUT
  |  ┌──────┴──────┐   ┌──┴───┐     ┌──────┴─────┐
  |   Doc          ··> Doc Hash ─┐
  |                              ├─> Doc.Signature
  |   private key  ··············┘   (r, s, v) in ECDSA
  ```
  ```
  | 3) VERIFYING ALGORITHM
  |      INPUT                         OUTPUT
  | ┌──────┴─────┐                  ┌────┴──────┐
  |  Doc          ··> Doc Hash ─┐
  |  public Key   ··············┼─>  TRUE | FALSE
  |  Doc.Signature··············┘
  ```
  ```
  | Public Key Recovery (Optional)
  |      INPUT                         OUTPUT
  | ┌──────┴──────┐                 ┌────┴──────┐
  |  Doc Hash -----------------─┐
  |                             ├─>  signer pub.K
  |  Doc.Signature ─ ─ ─ ─ ─ ─ ─┘
  |   (r, s, v )
  ```
  Key Recovery allows to verify a signature knowning
  only the message hash and its signature.
  This imply that we can store only [message, sign]
  ( vs [message, sign., pub.key])

WARN: key-generation algorithm is as important as the encryption or signing.
"How Perfect Offline Wallets Can Still Leak Bitcoin Private Keys"
<https://arxiv.org/abs/1501.00447>

> """... As standardized, the signature produced by ECDSA for a pair of
> a message and a key is NOT deterministic. This work shows how this
> non-deterministic choice can be exploited by an attacker to leak
> private information through the signature without any side channels,
> first discovered in 1997, and it affects ECDSA in the Bitcoin protocol. """

[[crypt_asymmetric.101}]]

[[standards.rsa,standards.dsa,]]


## DIGITAL SIGNATURE HISTORY [[{standards]]
  ```
  | 2 Approaches                                  YEAR
  | │
  | ├> RSA                                        1977 (family of discrete-log
  | │                                                   based sign.schemes)
  | ├> NIST DSA Digital Signature Algorithms      1985 (family of discrete-log 
  | │  │                                                based sign.schemes)
  | │  ├> (Used for) DSS Dig.Sig. Standard        1994
  | │  └> When replacing Mod N by Elliptic Curve  1978
  | │     ECDSA                                   2005
  | │     Used, amongst many others, by
  | │     Bitcoin/Ethereum/... to sign TXs
  | │  (Patents in Schnorr signatures forced NIST to
  | │   discartd it in favor of weaker alternatives)
  | │
  | ├> Schnorr patented signature method          1989 (expired in 2008).
  | │  (safer than DSA equivalent)
  | │  ├> EdDSA (Ed25519)                         2011 (By Daniel J.Bernstein, 
  | │  │                                                Niels Duif, Tangja Lange, 
  | │  │  Variant of Schnorr using Twisted              Peter Schwabe, Bo-Ying Yang
  | │  │  Edwards Curves.                               et all)
  ``` │  Edwards Curves.                               et all)

* 1976: Whitfield Diffie and Marting Hellman describe the notion of digital Signature
  (previous work existed but not disclosed in public)
* 1977: The RSA algorithm is invented (1st version, "primitive algorithm")
  * (R)onal Rivest, Adi (S)hamir, Len (A)dleman
  * MIT was granted US patent 4.405.829 from 1983-2000
* 1978: Jacques Vélu, publish<br/>
  "Courbes elliptiques munies d'un sous-group Z/nZxmu_n"
  Société Mathématique de France, 57, 1-152, Paris, 1978.
  <http://archive.numdam.org/item/MSMF_1978__57__1_0/>
* 1985: ElGamal signature scheme by Taher Elgamal, later adopted as DSS/DSA standard by
  US Governamental agencies.<br/>
  (REF: "Applied Cryptography", Bruce Schneier, ISBN 0-471-11709-9)
* 1985: Neal Koblitz[7] and Victor S. Miller[8] suggest the use
  of elliptic curves in cryptography<br/>
  (We must wait until 2004/2005 to see broad ussage).
  * 1985 <https://link.springer.com/chapter/10.1007%2F3-540-39799-X_31>
  * 1987 <https://www.jstor.org/stable/2007884?seq=1> 1987
* 1988: Shafi Goldwasser, Silvio Micaly and Ronald Rivest rigorously define the
  security requirements of digital signature schemes.
* 1989  Schnorr patents its signature method
  <https://patents.google.com/patent/US4995082>  (expired by 2008).<br/>
  As of 2013+ software companies tend to replace ECDSA with Schnorr.<br/>
  2014: C&P from <https://ripple.com/dev-blog/curves-with-a-twist/>
  ...  After months of analysis and testing, we’ve concluded
  that a Schnorr-based cryptosystem will greatly enhance the
  security, flexibility, and performance of the Ripple protocol
  (when compared to Koblitz curves with secp256k1 parameters and
  ECDSA signatures as defined in :
  Standards for Efficient Cryptography<br/>
  <http://www.secg.org/collateral/sec2_final.pdf> )
* 1991: Phil Zimmermann developes PGP
* 1994: First DSA schema approved as DSS (US National Institute of Standards and Tech NIST)
  and specified in Federal Information Processing Standard (FIPS) 186 (FIPS 186-1):<br/>
  ```
  DSA can use lot of "tunable switches" like the hash-funcs,
  (L, N)-param-length,....  DSS defines what those "tunnable switches"
  will be for the standard:
  - It should use hash-function: SHA-1 (recently SHA-2).
  - It should use specific length pairs: (2048,224), (3072,256),...
  - 2013 FIPS-4: <https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf>
  <https://en.wikipedia.org/wiki/Digital_Signature_Algorithm>
  WARN : See problems with DSA/DSS(year 2015)
  ```
* 1995: Kocher described a new attack on RSA based on sufficient detail on
  hardware and time-measures to deduce the decryption key d quickly.
  Randomization of time output is needed to avoid it.
* 1995: FIPS 180-1, Secure Hash Standard
* 1998: ANSI X9.62-1998: Public Key Cryptography for the Financial 
  Services Industry. The Elliptic Curve Digital Signature Algorithm. 
  January 1999.
* 1999: NIST recommends 15 elliptic curves.
* 2000: ESIGN Act makes online signatures legally binding
* 2013: Second DSA schema approved by DSS (FIPS 186-2).
* 2005: Elliptic Curve DSA <https://www.ietf.org/rfc/rfc4050.txt>
* 2009: PAdES: PDF Advanced Electronic Signatures <https://en.wikipedia.org/wiki/PAdES>
* 2009: Benjamin Moody factored an RSA-512 bit key in 73 days using 
  only public software (GGNFS) and a desktop computer with less than 
  five gigabytes of disk storage and ~2.5 Gbytes RAM.
  * In 1999 it required the equivalent of 8_400MIPS years/seven months.
  * First exploits where reported in 2011 (minimun 2048 bit is recomended)
* 2009: secg.org SEC 1: Elliptic Curve Cryptography
  <http://www.secg.org/sec1-v2.pdf>
* 2010: secg.org SEC 2: Recommended Elliptic Curve Domain Parameters
  <http://www.secg.org/sec2-v2.pdf>
* 2011: Daniel Bernstein publishes Ed25519 Signature (based on Schnorr Schema)
* 2013: secg.org SEC 3: Elliptic Curve Qu-Vanstone Implicit Certificate
  Scheme (ECQV)
* 2013: The New York Times stated that Dual Elliptic Curve Deterministic
  Random Bit Generation (or Dual_EC_DRBG) had been included as a
  NIST national standard due to the influence of NSA, which had
  included a deliberate weakness in the algorithm and the
  recommended EC. RSA Security in September 2013 issued an advisory
  recommending that its customers discontinue using any software
  based on Dual_EC_DRBG.<br/>
  WARN: Cryptography experts have also expressed concerns over the
  security of the NIST recommended elliptic curves, suggesting a
  return to encryption based on non-elliptic-curve groups.
* 2013: 4th DSA schema approved by DSS (FIPS 186-4).
* 2015: NSA announces plans to replace some ECDSA Suite B algorithms
  with a new cipher suite due to concerns about quantum-computing
  attacs on ECC.<br/>
  SSH decided to drop DSS/DSA keys in favor of RSA due to "inherit weakness"
  <https://www.gentoo.org/support/news-items/2015-08-13-openssh-weak-keys.html>
  * See also critics to DSS @:
  <http://groups.csail.mit.edu/mac/classes/6.805/articles/froomkin-metaphor/partIAB.html>
[[}]]

## Who-is-Who:
* RSA Security LLC: Pionering company founded by the creators of the
  RSA algorithm. They also developed the first PKCS standars.
  (Public Key Cryptography Standards)
  Today most standars pass through the IETF (Internet Engineering Task
  Force) in order to standardize their protocols.
* NIST: US agency in charge of define standards an develop guidelines
  for use in fovernment related functions as well as other
  public/private organizations. It has standadized many widely used
  cryptographic primitives. (e.g. AES symmetric was standarized
  after several year analyzing different candidates).

[[{standards.rsa,standards.dsa,crypt_asymmetric,use_case.signature]]
## RSA SIGNATURE  [[{]]
* ("Symmetric" to Encryption with Pub.Key)
  ```
  | ┌───────┐        ┌──────┐  ┌────────────┐   ┌────┐
  | │Message│───────>│CONCAT│─>│Message     │──>│HASH│──────┐
  | └───────┘        └──────┘  │            │   └────┘   ┌──v────┐
  |   │                 ^      ├────────────┤            │Compare│
  |   │ ┌────┐  ┌──────┐│      │C(PrivKey,h)│─>┌──────┐  └───────┘
  |   └>│HASH│─>│Sign  │┘      └────────────┘  │Deciph│     ^
  |     └────┘  └─^────┘                       └──^───┘─────┘
  |               │                               │
  |             PrivKey                         PubKey
  | └─────────────────┬─────────────────────┘└──────┬────────────┘
  |                  Sign                        Verify
  ```

  [[01_PM.WiP]] RSA Schema (Key-Pair Generation, Signature, Verification) algorithms.
[[}]]

## (EC)DSA  [[{]]
Can be used with prime number groups or with Eliptic Curve groups.

  ```
  DSA SIGNATURE:
  | ┌───────┐              ┌──────┐  ┌───────┐
  | │Message│─────────────>│CONCAT│─>│Message│─────┐
  | └───────┘              └──────┘  │       │  ┌──v─────┐
  |   │                       ^      ├───────┤  │Verifier│─┐
  |   │  ┌────┐      ┌──────┐ │      │s(sign)│─>└───^────┘ │
  |   └─>│HASH│─>h1─>│Sign  │─┘      ├───────┤      │  ┌───v───┐
  |      └────┘      └─^──^─┘        │r(sign)│─┬────┘  │Compare│
  |                    │  │          └───────┘ │       └───^───┘
  |              PrivKey  K(Non secret)        └───────────┘
  | └──────────────────────┬─────────────────┘└──────┬──────────┘
  |                       Sign                     Verify
  ```

  ```
  |  DSA PRESETUP: PUBLIC (CONSTANT) PARAMETERS DEFINED BY                ┌─ ECDSA PUBLIC PARAMETERS DEFINED BY ─┐
  |                Standards like DSS protocols                           │  Standards like DSS protocols        │
  | REF: <http://coders-errand.com/details-of-ecdsa-signatures/>          │ q : large power-of-2 | large-prime  ¹│
  |                                                                       │ EC: an adequate EC with N points and │
  | 0     q    2q    3q    4q    Nq==p-1                                  │     coefficients defined over        │
  | ├───g─┼─────┼─────┼─────┼──···┴┐  PUBLIC (CONSTANT) PARAMS DEFINED BY │     finite field Fq. E.g., for Bicoin│
  | ·   ^  ^                      ^^  STANDARD OR PROTOCOL (p,q,g):       │     and Etheruem: secp256k1(y²=x³+7) │
  | ·   │  │                      │└·· p : (Large) Prime number with:     │ n : the order of a large sub-group of│
  | ·   │  │                      │·       2^L-1 < p < A^L                │     EC such that n is prime         ¹│
  | ·   │  │                      │·       Used to define 'group G' like: │ G : a generator for this n-order     │
  | ·   │  │                      │·        elements: 1,2,3, .......,p    │     sub-group.                       │
  | ·   │  │                      │·       operation: a x b mod p         │ "...It mostly boils down to replacing│
  | ·   │  │                      │·                                      │     group-of-integers  by            │
  | ·   │  └·························· q : Prime Number dividing p-1:     │     group-of-EC-points..."           │
  | ·   │                         └········ p-1 == q x N                  │                                      │
  | ·   └······························g : generator of order q.          │ ┌─ KEYPOINT: ───────────────────────┐│
  | ·                             ··       Visually:                      │ │ groups on ECs are harder to attack││
  | └┼──┼────────┼───────────┼···─┴┐                                      │ │ than integer groups,              ││
  |  ·  g        g²         g^(q-1)  <···· Subgroup of G formed           │ │ => much smaller value of q needed ││
  |  ·  g        mod p      mod p          by g⁰,g¹,...g^q                │ │    =>  much shorter signatures    ││
  |  └ g^q mod p (== 1)      ·                                            │ └───────────────────────────────────┘│
  |  ·  ·   ·    ·           ·         0     q    2q      Nq==p-1         │                                      │
  |  ·  ·   ·    ·           ·         └───g─┼─────┼───···─┴┐             │ Note: q is larger thant Fq.          │
  │  ·  └·····························1+·    ·              p             └──────────────────────────────────────┘
  |  ·           └····················2+ ·   ·
  |  ·                       ·         ·  ·  ·
  |  ·                       ·         ·   · ·
  |  ·                       └······q-1+    ··
  |  └································q+·····┘
  | E.g.: In Bitcoin/Ethereum using secp256k1 we have:
  | q = 115792089237316195423570985008687907853269984665640564039457584007908834671663
  | n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
  ```

  ```
  |┌─ KEY-PAIR ALGORITHM ──────────────────────────────────────────────────────┐   ┌─ KEY GENERATION ────────────────────┐
  |│ 0     q    2q    3q          Nq==p-1                                      │   │ d == private1 = random[1, ..., n-1] │
  |│ └─────┼─────┼─────┼─y───┼──··─┴┐                                          │   │ Q == public1  = d·G                 │
  |│ └─x──┘              ^          p                                          │   │                  ^                  │
  |│   ^                 ·                                                     │   │ (vs d^G in integers, since internal │
  |│   └······················ STEP 1) private1 = random[1, q-1]               │   │  group op in EC is seen as addition │
  |│                     ·             i.e, private1 ∈ "N mod q" field         │   │  -vs multiplication -)              │
  |│                     └···· STEP 2) Calculate Public key:                   │   │                                     │
  |│                                   y = public1 = g^x mod p                 │   │                                     │
  |│                                   i.e, private1 ∈ "N mod p" field         │   │                                     │
  |└───────────────────────────────────────────────────────────────────────────┘   └─────────────────────────────────────┘
  ```

  ```[[{101]]
  | SIGNATURE GENERATION ALGORITHM                                  ┌─ SIGNATURE GENERATION ─────────────┐
  | INPUT: private1, m (message)                                    │  INPUT: private1, m (message)      │
  | 0    q    2q    3q      Nq==p-1                                 │  STEP 1)                           │
  | └─K─┼────┼────┼────┼──···┴┐<· STEP 1)                           │  k = random[1, ..., n-1]           │
  |                               K = random[1, q-1]                │                                    │
  |                                                                 │                                    │
  | └┼──┼────────┼──···─┼─···   <· STEP 2)                          │  STEP 2)                           │
  |    g        g²    g^K         Calculate:                        │  Calculate:                        │
  |             mod p mod p       X = g^K mod p                     │  X = (x1, y1) = k·G                │
  |                               r = X mod q                       │  r = x1                     mod n  │
  |                               e = Hash(m)                       │  e = Hash(m)                       │
  |                               s = K-1 ⋆(e + private1⋆r) mod q   │  s = k-1 * (e + private1·r) mod n  │
  |                               Retry STEP 1)                     │  Retry STEP 1) if either r|s are 0.│
  |                               (new K) if r|s are 0              │                                    │
  |                               STEP 3) Return signature:         │  STEP 3) Return signature:         │
  |                               (r , s)                           │  (r, s)                            │
  |                               └──┬──┘                           │  NOTES:                            │
  |                               MOD Q FIELD => Log₂q ==           │  - y1 is never used for sign.      │
  |                               "SECURITY LEVEL" OF THE SCHEME.   │  q >> Fq => N EC coord. map same r │
  |                                                                 └────────────────────────────────────┘
  ```[[}]]

  ```
  | SIGNATURE VERIFICATION ALGORITHM            ┌─ SIGNATURE VERIFICATION ────────────┐
  | INPUTS: (r,s) signature mode-q, m (message) │  INPUTS: m, (r,s) sig               │
  | Calculate:                                  │  Calculate:                         │
  | e = Hash(m)                                 │  e = Hash(m)                        │
  | U1 = e/s mod q                              │  u1 = e / s mod n                   │
  | U2 = r/s mod q                              │  u2 = r / s mod n                   │
  | X = g^U1 * public1^U2                       │  (x1, y1) = X = u1G + u2Q           │
  | return X mod q == r                         │  return X != "point-at-infinity" && │
  |                                             │         (x1 mod n == r)             │
  |                                             └─────────────────────────────────────┘
  ```
[[}]]

## RSA vs DSA Comparative [[{02_doc_has.comparative]]

  ```
  |RSA                                        DSA
  |─────────────────────────────────────────  ─────────────────────────────────────────
  |✓ compatible with integer prime number     - variant of the ElGamal adding secondary
  |  factorization                              160-bit modulus(q) to speed up execution
  |✕  In-compatible with Ellip.Curves           and reduce the size of final signature.
  |                                           ✕ Can NOT be used for encryption
  |✕ computationally more expensive           ✓ (EC)DSA allows to recover public key from
  |✓ Does not require a source of randomness    a given message and signature.
  |  Prefered of embedded systems/SDCarts/..  ✕ Requires a high-quality source of randomness
  |  [[{use_case.IOT}]]                         (except ed25519 and maybe other ECDSA scheme)
  ```
[[}]]

[[{02_doc_has.comparative,crypt_asymmetric,use_case.signature]]
## ed25519 vs ECDSA "secp256k1" Digital Signatures Comparative 

NOTE: 25519 comes from: (2^255 - 19).is_prime() # returns True  [[{doc_has.key-point}]]

### Sumary from <https://martin.kleppmann.com/papers/curve25519.pdf>

* """ ...we will define a group using the Curve25519 elliptic curve.
   This group has order
   ```
   |h * q ; h = 8
   |        q = 2252 +27742317777372353535851937790883648493  (prime) or
   |              ┌────────────────────────── 63 hex chars ──────────────────────┐
   |            0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed
   |             ┌┴─┐
   |             0001
   |             ···└· 2^252 => "only slightly larger than 2^252"
   |             ··└·· 2^253
   |             ·└··· 2^254
   |             └···· 2^255
   ```
   *  The parameters are chosen such that the order of the group is the
     product of a small integer h (which is called the cofactor, in this
     case 8), and a prime q that is slightly greater than a large power of
     two:
   * Lagrange’s theorem states that if a group E has a subgroup
     E′, then the order of E is divisible by the order of E′.  Since
     the set of powers of a group element generates a subgroup, this means
     the order of any group element must be a factor of the order of the
     group. Therefore, each Curve25519 group element must have order
     either 1, 2, 4, 8, q, 2q, 4q, or 8q:<br/>
     those are all of the factors of 8q, and thus all of the possible orders
     of group elements.
   * The group would be simpler if it had a prime order (i.e. if the
     cofactor was h = 1), since then all group elements would have order
     either 1 or q. However, elliptic curve groups using Montgomery curves
     such as Curve25519 (see Section 4) always have a cofactor that is a
     multiple of 4. Since Montgomery curves have other advantages, a
     design decision of Curve25519 was to accept the cofactor of 8, even
     though it makes the group more complicated to use safely
   * ... Curve25519 uses the Montgomery curve:
     ```
     | y² = x³ + Ax² + x  ; A = 486662
     ```
   """
* both Ed25519 and eCDSA "secp265k1" are EdDSA signature schemes.
  Ed25519 uses SHA-512 (SHA-2) and Curve25519 (vs secp256k1 curve)
  Extracted from <https://tools.ietf.org/html/rfc6979><br/>
  """ [[{use_case.IOT}]]
  ed25519 deterministic signatures retain the cryptographic       
  security features associated with DSA/ECDSA digital signatures
  but can be more easily implemented, since NO NEED FOR A SOURCE
  OF HIGH-QUALITY RANDOMNESS (point of failure) for the "k"
  parameter.
    NOTE: It is possible to turn DSA and ECDSA into deterministic
  schemes by using a deterministic process for generating the
  "random" value "k" fulfilling some crypto. characteristics.
  """ 
* secp256k1 curve has a linear private-key space:
  ```
  |   prv.key1 > public key of (prv.key1)
  |   prv.key2 > public key of (prv.key2)
  |
  |   prv.key1 > public key of (prv.key1 + prv.key2)
  | + prv.key2   └─────────────┬───────────────────┘
  |              equal to (due to linearity) sum of
  |                  public key of (prv.key1)
  |                + public key of (prv.key2)
  ```
* Ed25519 private-key space is NOT linear.
  It uses a twisted Edwards curve bi-rationally equivalent
  to the Montgomery curve Curve25519, SINCE PUBLIC-KEY IS
  GENERATED FROM PRIVATE KEY BY FIRST HASHING THE PRIVATE KEY
  WITH SHA-512.
  ```
  | prv.key1            > pub.key of sha512(prv.key1)
  | prv.key2            > pub.key of sha512(prv.key2)
  | prv.key1 + prv.key2 > pub.key of sha512(prv.key1 + prv.key2)
  | prv.key1 + prv.key2 > pub.key of sha512(prv.key1 + prv.key2)
  ```
  Ed25519 on the other side creates some sort of problems,  [[qa.UX]]
  for example to create HD Wallets as explained in:
  <https://www.jelurida.com/sites/default/files/kcdsa.pdf>

## Schnorr("ed25519 version od EdDSA")
* REF: <http://ed25519.cr.yp.to/>,
  <http://blog.siphos.be/2015/08/switching-openssh-to-ed25519-keys/>,
  <http://chneukirchen.org/blog/archive/2014/02/the-road-to-openssh-bliss-ed25519-and-the-identitypersist-patch.html>
* designed by prominent cryptographer Daniel J. Bernstein
* elliptic curve implementation more optimal and secure than equivalent
  design schemes based on secp256k1 (Bitcoin/Ethereum/...)
* Summary of advantages versus secp256k1 curve:
  * Large absolute value for the CM field discriminant
    (large |D| )—although there is no evidence of security problems with small |D|
    <http://safecurves.cr.yp.to/disc.html>
  * Supports simple, fast, complete(http://safecurves.cr.yp.to/complete.html)
    constant-time single-scalar multiplication using a Montgomery ladder
    (http://safecurves.cr.yp.to/ladder.html)
  * A random curve point can be represented in a way that's indistinguishable
    (<http://safecurves.cr.yp.to/ind.html>) from random data.
  * Faster performance.
  * ...  Our initial tests and analysis suggest ...  Curve25519 halves 
    verification time versus secp256k1 based on efficient implementations
    of both curves.[[{crypt_asymmetric.performance]]
    * These results were achieved with lower variance, which point to the
      constant time properties of Curve25519.
    * the default signature format for Ed25519 allows batch signature
      verification, which promises twice the performance of DSA.
    Benchmarking:
    * <http://justmoon.github.io/curvebench/benchmark.html> Raw test results
    * <https://github.com/justmoon/curvebench>              Benchmark source code
    * the new curve implementation is expected to quadruple 
      performance versus secp256k1 based on our preliminary benchmarking.  
      [[}]]
  * Extracted from <https://www.mail-archive.com/cypherpunks@cpunks.org/msg02419.html>
    sums up the benefits of Schnorr as follows:
    "simple blinding, compact multi-sig, clearer security proofs, better security margin,
     less dependence on hash properties."
* Summary of advantages versus ECDSA signature schemas:
  * Simpler to securely implement.
  * Composable threshold signatures without multi-party computation.
  * Verification happens off-network allowing for sophisticated functionality
    without increasing network load or complexity.
  * Conducive to highly distributed systems. [[qa.UX]]
  * Less constraints allows for more optimal and secure design schemes.
  * DSA schemes are difficult to manage because the schemes are easy to    [[{qa]]
    get wrong.  An improper implementations is trivial to break, and what
    might seem like a minor misstep can precipitate a system-wide
    vulnerability—as demonstrated by
    <http://nakedsecurity.sophos.com/2012/10/25/sony-ps3-hacked-for-good-master-keys-revealed/>
    ...  Hackers were able to access full control of the PS3 
    employing "simple algebra" after Sony set a constant in its custom 
    DSA implementation instead of a randomly generated number.  The 
    sensitivity of DSA signatures to human error allowed this single 
    oversight to fully compromise the console's encryption protections, 
    exposing the platform and Sony's partners to the perpetual threat of 
    piracy.
  * Alternatively, Schnorr signatures are more forgiving and simpler 
    to implement because its security is inherently more robust based on 
    the scheme’s dynamic hash function
    <http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&amp;arnumber=4908440>
    The ephemeral public value r is tightly bound to the message, 
    which means that the security of the scheme is no longer dependent on 
    the collision resistance of the hash function.
    <http://www.cs.bris.ac.uk/Publications/pub_master.jsp?id=2001023> [[}]]
  * Independent verification and combining: [[{qa.UX]]
    Another advantage of Schnorr is related to threshold signatures
  * ECDSA can create threshold signatures, but requires multi-party computation
    <http://en.wikipedia.org/wiki/Secure_multi-party_computation>
    This means that the number of participants required to generate a signature
    without revealing their secrets is twice the number of shares 
    required to recover the key.
    In contrast, Schnorr has no such restriction. Shares of a 
    signature can be independently verified and then composed. [[}]]
* External Resources:
  * Safe?Curves: <http://safecurves.cr.yp.to/>
  * Browser support <https://security.stackexchange.com/questions/31772/what-elliptic-curves-are-supported-by-browsers>
  * TLS-RSA cert. with elliptic curve:
    <https://crypto.stackexchange.com/questions/30503/tls-rsa-certificate-with-elliptic-curve-negotiation>
  * Comparisions of secp256r1-vs-secp256k1 Elliptic Curves:
  <https://crypto.stackexchange.com/questions/18965/is-secp256r1-more-secure-than-secp256k1>
  * Minimal implementation of Ed25519Signature2018 in JavaScript:
    <https://github.com/transmute-industries/Ed25519Signature2018>
    """.. This library focuses on verification of signatures, and does not
    attempt to mix validation with verification logic. You may prefer to
    use jsonld-signatures..."""
[[}]]

## XML Signature [[{use_case.signature,standards.xml,02_doc_has.comparative]]
<https://en.wikipedia.org/wiki/XML_Signature>
* also called XMLDSig, XML-DSig, XML-Sig
* XML syntax for digital signatures
* W3C recommendation
* it has much in common with PKCS#7 but is more extensible
* used by various XML related technologies like SOAP or SAML
* typically used toto sign XML documents,
  but anything that is accessible via a URL can be signed
* An XML signature used to sign a resource outside its containing
  XML document is called a detached signature;
* If used to sign some part of its containing document, it is
  called an enveloped signature;
* if it contains the signed data within itself it is called an
  enveloping signature.
* creation of XML Signatures is substantially more complex
  than the creation of an ordinary digital signature because
  a given XML Document may have more than one legal serialized
  representation<br/>
  XML canonicalization transform is employed to alleviated some of
  those problems<br/>
  (See detailed description in Wikipedia source)
[[}]]

[[{standards.OASIS,01_PM.TODO]]
NOTE: *AdES formats are the ones widely legally accepted for business transactions,
      eg. eInvoincing.
## OASIS XAdES (X)ML (Ad)vanced (E)lectronic (S)ignatures [[{use_case.signature,standards.xml,PM.TODO]]
<https://www.w3.org/TR/XAdES/>
<https://en.wikipedia.org/wiki/XAdES>
  The Cryptographic Message Syntax (CMS) is the IETF's standard
  for cryptographically protected messages. It can be used to
  digitally sign, digest, authenticate or encrypt any form of
  digital data.
[[}]]

## OASIS XML DSS (D)igital (S)ignature (S)ervices (Europa.eu) [[{]]
(Not to be confused with Digital Signature Standard DSS)
<https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=dss>

https://ec.europa.eu/cefdigital/wiki/display/CEFDIGITAL/Start+using+Digital+Signature+Services+-+DSS
open-source software library  for  electronic signature creation and
validation . DSS supports the creation and verification of interoperable
and secure electronic signatures in line with European legislation.
In particular, DSS aims to follow the eIDAS Regulation and related standards closely.

DSS can be re-used in an IT solution for electronic signatures to ensure that
signatures are created and verified in line with European legislation and
standards. DSS allows re-use in a variety of different ways: in an applet, in
a stand-alone application or in a server application. DSS can also be used as
a reference implementation for IT solutions which do not directly re-use it.
Demos are also available to assist the use of DSS as a reference implementation.

The library,  realised in Java , is open-source, available to all Member States
, businesses and citizens for re-use in electronic signature solutions. It is
continuously updated and maintained to anticipate and follow developments in
regulations and standards.

Anyone can integrate it and redistribute it under the terms of the Lesser
General Public License (LGPL 2.1).

In accordance with ETSI standards, DSS supports various document and
signature formats including PAdES, XAdES, CAdES and ASiC and is compliant
with Implementing Decision 2015/1506/EU. A “cook-book” is also provided with
documentation targeting implementers/developers and aiming at facilitating
the integration and use of DSS in their applications.
[[}]]

## PAdES(PDF) format (AES for PDF)  [[{PM.TODO]]
<https://en.wikipedia.org/wiki/Advanced_electronic_signature>
<https://en.wikipedia.org/wiki/PAdES>
[[}]]

## CAdES(CMS) format [[{PM.TODO]]
<https://en.wikipedia.org/wiki/CAdES_(computing)>
<https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax>
  Extensions to 'Cryptographic Message Syntax'
- ASiC format (Associated Signature Containers)
<https://en.wikipedia.org/wiki/Advanced_electronic_signature>
  ASiC Baseline Profile.
  specifies the use of container structures to bind together one
  or more signed objects with either advanced electronic signatures
  or time-stamp tokens into one single digital (zip) container.
[[}]]

## JaDES vs EADES [[{use_case.signature,02_doc_has.comparative,01_PM.TODO]]
Why do we want to support AdES formats using x509 certificates? JAdES
may be the only one worth considering if it can be used e.g. in a VC
proof and under certain conditions... I'd even argue that JAdES could
be just the adoption of a VC with a well defined proof format, but
I'm not sure this is the plan of ETSI ESI TC.

I put this here as it was in Jesus' proposal. We never discussed in
detail, what we'd support. + this doc is not very up to date.

However, I would like to check that we are not doing something
"incompatible" or that makes somewhat difficult that representation
(I have no idea of what can it be, just it may be woth checking).
The JAdES standard is ongoing work in ETSI
(https://portal.etsi.org/webapp/WorkProgram/Report_WorkItem.asp?WKI_ID=52897),
and they want to publish in March this year.
[[}]]

[[}]]


# ADVANCED PRIMITIVES

[[{use_case.data_integrity,crypt_symmetric,02_doc_has.comparative,01_PM.TODO]]
## FERNET Simmetric Encryption 

* Fernet guarantees that a message encrypted using it
  can NOT be manipulated or even read without the key.
* Fernet also has support for implementing key rotation via MultiFernet. [[qa.UX]]
[[}]]

## CRYPTO ACCUMULATOR [[{101,crypt_oneway.hash,crypt_oneway.accumulator,use_case.privacy,use_case.data_integrity,01_PM.TODO]]
* introducced in 1993 by Benaloh and de Mare.
* one way non-invertible function.
* It answers a query as to whether a potential candidate is
   a member of a set without revealing the individual members of the set.
* They are the cryptographic counterpart of Bloom Filters data structure:
  <https://hal.archives-ouvertes.fr/hal-00999432/document>
  * A Bloom filter is a space-efficient probabilistic data structure,
    used to test whether an element is a member of a set.
    Bloom filter setup)
    ```
    |                     bloom-filter0 = 000000000000...........0
    | Element1 > hash1 >  bloom-filter1 = bloom-filter 0   || hash1
    | Element2 > hash2 >  bloom-filter2 = bloom-filter 1      hash2
    | ...                 ...
    | ElementN > hashN >  bloom-filterN = bloom-filter N-1    hashN
    ```
  * Bloom filter Ussage)
    ```
    | Q: ElementI belongs to Set?
    | A: ElementI > hashI
    |    if (hashI && bloom-filterN == hashI )
    |       "maybe" (false positives are possible)
    |    else 
    |       "definetly no"
    ```
  * Crypto Accumulator Ex:
    ```
    large composite number
    CP01 = P1 x P2 x P3 x ... PN
           └────────┬──────────┘
    New members may be added or subtracted to the set of
    factors simply by multiplying or factoring out the number respectively.
    ```
    Q: Does P2 "belongs" to CP01?<br/>
    A: Yes, but we still don't known P1, P3, ... PN<br/>
- Use case include: time-stamping schemes , search on encrypteddata ,
  data aggregation in sensor networks [19] and distillation codes.
- Sanderet al. use RSA accumulator to designblind and auditablea
  membership proof scheme in the context of e-cash. The ideais that an
  accumulator of all the valid electronic coins is created and
  published.During coins transfer, anyone can verify the validity of
  the exchange thanks tothe accumulator.

Extracted from:
<https://medium.com/@aurelcode/cryptographic-accumulators-da3aa4561d77>
"""... We can think of accumulators as a super-charged hash function that
  works on sets. A regular hash function, like SHA-3, takes a single message and
  outputs a fixed-size hash. An accumulator, however, takes a set of values and
  turns them into a single number, also of constant size. 
  ```
  | Alice secret
  |   > alt 1: hash     ··> publish hash ··> reveal message to Bob (Bob can check)
  |            secret 
  |   > alt 2: add to   ··> publish accu ··> reveal message to Bob, Bob can check,
  |            accumulator                   but the rest of secrets of the
  |                                          accumulator stay in place.
  ```
"""

## Batching Techniques for Accumulators
<https://eprint.iacr.org/2018/1188.pdf>
* Batching Techniques for Accumulators with Applications to IOPs and 
  Stateless Blockchains
* Abstract:
  ```
  We  present  batching  techniques  for  cryptographic  accumulators
  and  vector  commitments  in  groups  of  unknown  order.
  .. tailored for distributed settings where no trusted
  accumulator manager exists and up-dates to the accumulator are
  processed in batches.  We develop techniques for non-interactively
  aggregating  membership  proofs  that  can  be  verified  with
  aconstant number of group operations.  We also provide a constant
  sized batchnon-membership  proof  for  a  large  number  of
  elements.<br/>
    We use these new accumulator and vector commitment constructions t
  design a stateless blockchain, where nodes only need a constant
  amount of storage inorder to participate in consensus.
  Further, we show how to use these techniquesto reduce the size
  of IOP instantiations, such as STARKs.
  ```
* Applications:
  * Stateless blockchains
  * Short IOPs:<br/>
      Merkle tree paths contribute significant overhead to both the proof
    size of a compiledIOP proof and its verification time. Vector
    commitments with smaller openings thanMerkle trees, or batchable
    openings (i.e.  subvector commitments), can help reducethis overhead
    ...  our VCs reduce the sizeof the Aurora proofs on a 220size
    circuit from 222 KB to less than 100 KB, a 54%reduction,  and  the
    size  of  STARK  proofs  for  a  circuit  of  252gates  from  600
    KBto approximately 222 KB, a 63% reduction.

* Conclusion:
  We expect that our techniques and constructions will have more
  applications beyond what  was  discussed.   Several  interesting  open
   questions  remain:   What  practical limitations occur when deploying
  the scheme?  Is it possible to efficiently compute unions  of
  accumulators?   This  is  certainly  true  for  Merkle  trees  but
  these  do  nothave the batching properties and constant size of RSA
  accumulators.  Similarly canone build an accumulator with constant
  sized witnesses from a quantum resistant assumption?   Additionally,
  we  hope  that  this  research  motivates  further  study  ofclass
  groups as a group of unknown order
[[}]]

# Advanced Signature Schemas

## MULTISIG VS THRESHOLD SIGNATURE SCHEMES [[{101,use_case.signature,02_doc_has.comparative]]

* Multi-signature schemes require the network to verify each signature,
  increasing load with the number of participants.
* Conversely, threshold signatures are generated offline and result in
  a single signature regardless of total number of parties participating.

## MULTISIGNATURE
<https://en.wikipedia.org/wiki/Multisignature>
* Digital signature scheme which allows a group of users to
  sign a single document. Usually, a multisignature algorithm produces
  a joint signature that is more compact than a collection of distinct
  signatures from all users
* A tuple of N signatures is the simplest (non-compacted)
  multisignature scheme
* Multisignature can be considered as generalization of both group
  and ring signatures.
  * Used to add additional security for cryptocurrency transactions
  * The required number of signatures is agreed upfront
  * Allows for the creation of N-of-M escrow services
  * Tree-signatures (Aug 24, 2015 by Pieter Wuille, Ph.D.):
    <https://www.blockstream.com/2015/08/24/treesignatures/>
   """Imagine you want to create a 1-of-11 multisig (with 11 known public keys).
   You compute the SHA256 hashes of the public keys involved and put them in
   a Merkle tree. In the graph below, all symbol names represent 32-byte hashes,
   except the 1. The 1 is used as a simple constant instead of a right branch
   when there is none."""
   ```
   |                             R
   |                          /     \
   |                       /           \
   |                   /                   \
   |               Z1                          Z2
   |            /      \                     /   \
   |       Y1              Y2              Y3     1
   |      /  \            /  \            /  \
   |   X1      X2      X3      X4      X5      X6
   |  / \     / \     / \     / \     / \     / \
   | K1 K2   K3 K4   K5 K6   K7 K8   K9 K10 K11  1
   ```
   "" Using the script in our Alpha sidechain, we can build a script that takes
   as input a public key, a signature, and a Merkle path. At verification time,
   it would use the Merkle path to prove that the public key belongs to a tree
   with root R, and that the signature checks out with that public key."""

## THRESHOLD CRYPTOSYSTEM
<http://en.wikipedia.org/wiki/Threshold_cryptosystem> (TODO)
* In order to decrypt an encrypted message, several parties
  (more than some threshold number) must cooperate in the decryption
  protocol. The message is encrypted using a public key and the
  corresponding private key is shared among the participating parties.
  Let "n" be the number of parties. Such a system is called (t,n)-threshold,
  if at least t of these parties can efficiently decrypt the ciphertext,
  while less than t have no useful information.
* Similarly it is possible to define (t,n)-threshold signature scheme,
  where at least t parties are required for creating a signature.
* The most common application is in the storage of secrets in multiple
  locations to prevent the capture of the ciphertext and the subsequent
  cryptanalysis on that ciphertext. Most often the secrets that are
  "split" are the secret key material of a public key cryptography key
  pair or the ciphertext of stored password hashes.
* In October 2012 after a number of large public website password
  ciphertext compromises, RSA Security announced that it would be
  releasing software that makes the technology available to the general
  public

## GROUP SIGNATURE
<https://en.wikipedia.org/wiki/Group_signature>
* A group signature scheme is a method for allowing a member of a group to
  anonymously sign a message on behalf of the group.
* For example, a group signature scheme could be used by an employee of
  a large company where it is sufficient for a verifier to know a message
  was signed by an employee, but not which particular employee signed it.
* Essential to a group signature scheme is a group manager, who is in charge
  of adding group members and has the ability to reveal the original signer
  in the event of disputes. In some systems the responsibilities of adding
  members and revoking signature anonymity are separated and given to a
  membership manager and revocation manager respectively.

## PROXY SIGNATURE
- A proxy signature allows a delegator to give partial signing rights
  to other parties called proxy signers. Proxy signatures do not offer
  Anonymity

## RING SIGNATURE
<https://en.wikipedia.org/wiki/Ring_signature>
* Type of digital signature that can be performed by any member of
  a group of users that each have keys.
  One of the security properties of a ring signature is
  that it should be computationally infeasible to determine which of
  the group members' keys was used to produce the signature
* Ring signatures are similar to group signatures but differ in two key
  ways: first, there is no way to revoke the anonymity of an individual
  signature, and second, any group of users can be used as a group without
  additional setup.
* Invented by Ron Rivest, Adi Shamir, and Yael Tauman, and introduced
  at ASIACRYPT in 2001
* Suppose that a group of entities each have public/private key pairs,
  (Pub_1, Secret_1), ..., (Pn, Secret_n).
  Party i can compute a ring signature σ on a message "m", on input
  ("m", Secret_i, Pub_1, ..., Pub_n). Anyone can check the
  validity of a ring signature given σ, m, and the public keys involved,
  P1, ..., Pn. If a ring signature is properly computed, it should pass
  the check. On the other hand, it should be hard for anyone to create a
  valid ring signature on any message for any group without knowing any
  of the private keys for that group.

## BLIND (CHAUMIAN) SIGNATURE *
<https://en.wikipedia.org/wiki/Blind_signature>
* Blind signature schemes exist for many public key signing protocols
  Blind RSA signatures, Blind ECDSA signatures,
* Java implementation:
  <https://archive.is/20130416090835/http://www.maniora.pl/?p=101">
* form of digital signature in which the content of a message is
  disguised/blinded before being signed. The resulting blind signature can
  be publicly verified against the original, unblinded message in the manner
  of a regular digital signature.
* Blind signatures are typically employed in privacy-related
  protocols where the signer and message author are different parties.
  Examples include cryptographic election systems and digital cash schemes:
  ```
  |Seq. Diagram                                                    
  |participant user # creates a message ("vote") and blinds it     
  |participant signer # authenticates user and sign blinded message
  |signer > user: authenticate user                                
  |user   > user: +message                                         
  |user   > user: message > blind > blinded_message                
  |user   > signer: blinded_message                                
  |signer > signer: +signed_blinded_message                        
  ```

## Identity-Based Aggregate Signatures
* REF: <https://link.springer.com/chapter/10.1007/11745853_17>
* An aggregate signature is a single short string that convinces any
  verifier that, for all 1 ≤ i ≤ n, signer S i signed message M i ,
  where the n signers and n messages may all be distinct. The main
  motivation of aggregate signatures is compactness. However, while
  the aggregate signature itself may be compact, aggregate signature
  verification might require potentially lengthy additional
  information – namely, the (at most) n distinct signer public keys
  and the (at most) n distinct messages being signed. If the verifier
  must obtain and/or store this additional information, the primary
  benefit of aggregate signatures is largely negated.
[[}]]

## BBS Signature Scheme [[{use_case.identity,PM.TODO]]
* <https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html>
* <https://github.com/decentralized-identity/bbs-signature>

# Data Integrity & Protection

## Content Addressable file systems.
* Famous example include Git an IPFS.
* Core idea: In normal FS, we use the unique FS paths and names
  as "unique ID" to identify a file.
  In Content Addressable FS we use the cryptographically secure
  hash of the file content as "unique ID".
  Standard paths and names are build on-top as yet another
  FS entry.
  * In C.A.FS two files with the same content map to the same
    storage.
  * If a file is corrupted (by hardware errors or attackers)
    the hash will not match anymore the stored content and the
    error is easy to detech.

## cryfs: Crypto filesystem for Clouds [[{qa.UX,PM.TODO]]
* REF: <https://www.cryfs.org/>
* CryFS encrypts files safely anywhere.
* It works well together with cloud services like Dropbox, iCloud, 
  OneDrive and others.
  <https://github.com/tldr-pages/tldr/blob/master/pages/common/cryfs.md>
  ```
  | $ cryfs $path_to_cipher_dir \        # <·· mount   encrypted FS
  |   $path_to_mount_point
  | $ cryfs-unmount $path_to_mount_point # <·· unmount encrypted FS
  | $ cryfs --unmount-idle 10 \          # <·· unmount after 10 min. of inactivity
  |   $cipher_dir_path $mount_point_path
  | $ cryfs --show-ciphers               # <·· Show a list of supported ciphers
  ```
[[}]]

## Hash Chain [[{crypt_oneway.hash,use_case.data_integrity]]
* REF: <https://en.wikipedia.org/wiki/Hash_chain>
* non-repudiation probe of data chronology
  ```
  doc1 > hash > has1 ─┬> hash > has2 ─┬> hash > has3 ─┬> hash
                 doc2─┘         doc3 ─┘         doc4 ─┘
  ```
* Merkle tree:
  * <https://en.wikipedia.org/wiki/Merkle_tree>
  * Allows to check if a leaf (data) is part of the tree with just a
    subset of the tree.
  * NOTE: In blockchain leafs are transactions and the tree is a block
  * It is deterministic and cryptographically verifiable:
    * The only way to generate a state root is by computing it from each
      individual piece of the state, and two states that are identical can
      be easily proven so by comparing the root hash and the hashes that led
      to it (a Merkle proof).
    * Conversely, there is no way to create two different states with
      the same root hash, and any attempt to modify state with different
      values will result in a different state root hash.

* Patricia Tree (Used by Ethereum,...)
  <https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/>
  Fun fact: ‘Trie’ is originally taken from the word ‘retrieval’, but most
  people pronounce it as ‘try’ to distinguish it from ‘tree’ when speaking.
  "...At one end of the trie, there are all of the particular pieces of
  data that describe state (value nodes). This could be a particular
  account’s balance, or a variable stored in a smart contract (such
  as the total supply of an ERC-20 token). In the middle are branch
  nodes, which link all of the values together through hashing. A
  branch node is an array containing the hashes of its child nodes, and
  each branch node is subsequently hashed and put into the array of its
  parent node. This successive hashing eventually arrives at a single
  state root node on the other end of the trie..."
[[}]]

## BitLocker Full Disk Encryption [[{PM.TODO]]
* REF: <https://en.wikipedia.org/wiki/BitLocker">BitLocker full disk encryptio
[[}]]

# Secret Protection

## HKDF
* HKDF stands for (H)MAC-based (K)ey (D)erivation (F)unction, RFC 5869
* requires high-entropy initial input key.
  <http://eprint.iacr.org/2010/264>

## Key derivation Fun. [[{secret_mng,101,01_PM.TODO]]
* <https://en.wikipedia.org/wiki/Key_derivation_function>
* Derive one or more secret keys from a first secret one.
* Many key derivation fun. admit a salt to avoid returning the same
  output keys from the same input secret
* (cite from Crypto101): Useful, for example, when a cryptographic protocol
  starts with a single secret value, such as a shared password or a secret
  derived using Diffie-Hellman-Merkle key exchange, but requires multiple
  secret values to operate, such as encryption and MAC keys.
* Two main categories, depending on the entropy content of the secret value
  which determines how many differnet possible values the secret value can
  take:
  * input secret is user-supplied (low entropy): Key derivation function will
    require lot of computing resources to avoid attackers to just compute all
    possible combinations. (scrypt)
  * input secret is random (high entropy): A trivial key derivation will
    suffice (e.g: HKDF)

## Argon2Id key derivation Fun.
<https://en.wikipedia.org/wiki/Argon2>
  selected as winner of the Password Hashing Competition in July 2015.
  * It maximizes resistance to GPU cracking attacks and time-memory-trade-off
    (TMTO) attacks.
  * It maximizes resistance to resist side-channel attacks.
  * It is an hybrid version (Recomended). The Internet draft[4] recommends
    using Argon2id except when there are reasons to prefer one of the other
    two modes.
[[}]]

## Shamir Secret sharing (SSS) [[{101,use_case.secret_mng]]
<https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>
* provides a method of secret sharing, where a secret is divided into parts,
  giving each participant its own unique part, where some of the parts or all
  of them are needed in order to reconstruct the secret.
   Counting on all participants to combine the secret might be impractical, and
  therefore sometimes the threshold scheme is used where any "k" of the parts
  are sufficient to reconstruct the original secret. For example
  "any 2 out of 3" shared pieces will reproduce the key.
   The essential idea of Adi Shamir's threshold scheme is that 2 points are
  sufficient to define a line, 3 points are sufficient to define a parabola, 4
  points to define a cubic curve and so forth. That is, it takes k points to
  define a polynomial of degree k − 1
* Use Cases: Password/Passphrase protection management
[[}]]

## VERIFIABLE SECRET SHARING (VSS) [[{secret_mng.VSS,01_PM.TODO]]

* <https://en.wikipedia.org/wiki/Verifiable_secret_sharing>
  In cryptography, a secret sharing scheme is verifiable if auxiliary    [[{qa.UX}]]
  information is included that allows players to verify their shares as
  consistent.
  More formally, verifiable secret sharing ensures that even if the
  dealer is malicious there is a well-defined secret that the players
  can later reconstruct. (In standard secret sharing, the
  dealer is assumed to be honest.)
  The concept was first introduced in 1985 by Benny Chor, Shafi
  Goldwasser, Silvio Micali and Baruch Awerbuch. (Same authors
  working of ZKPs)
  In a VSS protocol a distinguished player who wants to share the
  secret is referred to as the dealer. The protocol consists of two
  phases: a sharing phase and a reconstruction phase.
  Ex implementation: <https://github.com/dfinity-side-projects/vss>
[[secret_mng.VSS}]]

[[}]]

[[{protocol.tls]]
# TLS Protocol

* External Links:
  * https://en.wikipedia.org/wiki/Transport_Layer_Security
  * Mozilla SSL config generator:
  <https://mozilla.github.io/server-side-tls/ssl-config-generator/>
  * Mozilla Server Side TLS
  <https://wiki.mozilla.org/Security/Server_Side_TLS>
  * The Most Dangerous Code in the World: Validating SSL Certs ...:
  <https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf>

* SSL Server Test: free online service performing deep analysis of 
  the configuration of any SSL web server on the 
  public Internet. <https://www.ssllabs.com/ssltest/>
  [[{01_PM.troubleshoot}]]

[[{101,protocol.tls,standards.pki.x509,standards.web,tech_stack.java,tool.openssl]]
## TLS, X.509v3 
 
  ```
  | X.509 v3:            <·· ITU_T standard for Certificate 
  | =========                Storage and Serialization.
  | Version#                 Used, amongst others, by Internet 
  | Serial Number            TLS/SSL protocols.
  | Signature algorithm
  | Issuer name
  | Validity period
  | ---------------
  | Subject Name
  | Subject PK Info
  | Issuer  ID
  | Subject ID#
  | Extended attributes (Used by different services)
  | ──────────────────
  | CA3 Signature       <·· The signature is the 
  |                         non-repudiable claim made by 
                            the CA that X.509 certificate 
                            data is valid (from its point 
                            of view):
  ```

* The  certification path validation algorithm  allows
  delegation of signatured to an associative list of "trusted-by" CAs.
  ```
  | CA1 > trust for   > CA2 > trust for   > CA3 > CA3 Signed Certificate
  | └┬┘   certificate   └┬┘   certificate   └┬┘
  |  ·    issuance       ·    issuance       ·
  |  ·                   ·                   ·
  |  ·                   └─ intermediate CAs ┘
  | DIRECT TRUST            ASSOCIATVE TRUST
  ```
[[}]]

## openSSL How-To Summary [[{protocol.tls.openssl]]
* Ext. Refs:
  * <https://ciphersuite.info/cs/>:  DDBB about different chipher-suites strenghts
  * <https://en.wikipedia.org/wiki/X.509>
  * <https://www.openssl.org/docs/manmaster/man1/>
  * <https://www.ietf.org/rfc/rfc5280.txt> X.509 PKI
* Common openssl opts:
  * -in   : path for input certificate being examined. Many times
            STDIN from previous 'openssl s_client ...' is preferred.
            $ openssl s_client ... | openssl ...
  * -noout: prevents encoded version output (of request/response)
  * -text : Show OUTPUT in human readable text (vs hex formated binary)
  * -nodes: flag:  DO NOT  pass-phrase-encrypt Pub.Key

* Commonly used script/batch ENV.VARs:
  ```
  export DOMAIN="mydomain.com"
  export SUBJ="/C=ES/ST=Aragon/L=Zaragoza/O=MyOrganization/CN=${DOMAIN}"
  export NUM_OF_DAYS="999"
  ```

 ```
 | **Request>create>install new Server Certificate Flow**
 |   admin>admin: Create Private Key ← Pub.Key autogenerated from Priv.Key
 |   alt
 |     admin>admin : Sign self-Cert  ← Dev. Purposes
 |   else:
 |     admin>admin: Create CSR       ← CSR: Cert. Signing Request with Pub.key
 | ┌>  admin>CA    : CSR
 | │   CA←>admin   : Validate KYC,...← KYC: "Know Your Customer"
 | │   CA>CA       : Create Cert     ← Happy path. CSR approved.
 | │   CA>amdin    : Cert.
 | │   admin>server: Cert.           ← Server: Apache, Nginx, ...
 | │
 | └─ $ openssl req  -new  -nodes              ← Create key + CSR.
 |    -newkey rsa:2048 -keyout ${DOMAIN}.key \   ← Replace -newkey ... -keyout ...
 |    -out ${DOMAIN}.csr -subj "${SUBJ}" \         by -key ${DOMAIN}.key to reuse
 |                                                 already existing private key
 |    -addext "subjectAltName = DNS:foo.co.uk" \
 |    -addext "certificatePolicies = 1.2.3.4" \  ← Can Sign? Can
 ```

 ```
 | **Managing Private Keys**       | **dump x509 inf**
 | CREATE A PRIVATE KEY:           | $ openssl x509 -in myCert.pem -text
 |$ openssl \                      | $ openssl x509 -in myCert.crt -text -inform DER
 |    genrsa -des3 \                                           ^                 ^
 |    -out ${DOMAIN}.key 2048                     crt/cer admits PEM and DER binary
 |(Enter password when prompted)                  encoding. For binary the option
 |                                                "-inform DER" must be passed or
 |                                                the command will fail.
 | **VERIFY PRIVATE KEY**
 |$ openssl rsa -check -in ${DOMAIN}.key
 |
 | **Verify private key matches certificate and CS**
 | (If the output of each of the next command is identical there is an
 |  extremely high probability that the private key, certificate,
 |  and CSR are related)
 |  $ openssl rsa  -noout -modulus -in ${DOMAIN}.key | openssl md5
 |  $ openssl x509 -noout -modulus -in ${DOMAIN}.crt | openssl md5
 |  $ openssl req  -noout -modulus -in ${DOMAIN}.csr | openssl md5
 |
 | Encrypt/Decrypt private key
 |$ openssl rsa -des3 -in unencrypted.key -out encrypted.key
 |$ openssl rsa       -in encrypted.key   -out decrypted.key
 ```

 ```
 | Self-Signed-Cert
 | working on Chrome/Java/...
 |REF:
 |- chrome deprecates subject cn matching]
 |<https://textslashplain.com/2017/03/10/chrome-deprecates-subject-cn-matching/>
 |- Fixing Fixing Chrome 58+ [missing_subjectAltName] with openssl&amp;S.S.certs</a>
 |<https://alexanderzeitler.com/articles/Fixing-Chrome-missing_subjectAltName-selfsigned-cert-openssl/>
 |- getting-chrome-to-accept-self-signed-localhost-certificate
 |<https://stackoverflow.com/questions/7580508/getting-chrome-to-accept-self-signed-localhost-certificate/43666288#43666288>
 | create_root_cert_and_key.sh
 | |#!/usr/bin/env bash
 | |openssl genrsa -out rootCA.key 2048
 | |openssl req -x509 -nodes \
 | |    -days $NUM_OF_DAYS \
 | |    -key rootCA.key -sha256 \
 | |    -out rootCA.pem
 | |    -new
 |      ^^^^
 |      replace with -in $DOMAIN.csr to reuse crt
 ```

 ```
 ```
 | **create_certificate_for_domain.sh**
 | #!/usr/bin/env bash
 | 
 | if [ -z "$1" ]; then
 |   echo "Ussage: $0 myDomain.com"
 |   echo "           ^^^^^^^^^^^^"
 |   echo "    # alt1     wildcard"
 |   echo "        $0 www.myDomain.com"
 |   echo "           ^^^^^^^^^^^^^^^^"
 |   echo "    # alt2 non-wildcard"
 |   exit 1;
 | fi
 | if [ ! -f rootCA.pem ]; then 
 |   echo 'no rootCA.pem detected. Please, run create_root_cert_and_key.sh first, and try again!' 
 |   exit 1
 | fi
 | if [ ! -f v3.ext     ]; then
 |   echo 'Please download the "v3.ext" file and try again!'
 |   exit
 | fi
 | if [ -f $DOMAIN.key ]; then #  ← Create new Priv.Key || reuse existing one
 |   KEY_OPT="-key"
 |  else 
 |   KEY_OPT="-keyout"
 | fi 
 | 
 | cat << EOF > /tmp/__v3.ext
 | authorityKeyIdentifier=keyid,issuer
 | basicConstraints=CA:FALSE
 | keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
 | subjectAltName = @alt_names
 | 
 | [alt_names]
 | DNS.1 = $COMMON_NAME
 | EOF
 | 
 | openssl req -new -newkey rsa:2048 \
 |    -sha256 -nodes $KEY_OPT $DOMAIN.key \
 |    -subj "$SUBJECT" -out $DOMAIN.csr
 | openssl x509 -req -in $DOMAIN.csr \
 |    -CA rootCA.pem -CAkey rootCA.key \
 |    -CAcreateserial -out $DOMAIN.crt \
 |    -days $NUM_OF_DAYS -sha256 \
 |    -extfile /tmp/__v3.ext
 |
 | Ussage:
 |$ ./create_root_cert_and_key.sh        # ← STEP 01: create root Auth cert
 |
 |$ ./create_certificate_for_domain.sh \ # ← STEP 02
 |   mysite.com                          #   Alt 1
 |   www.mysite.com www.mysite.com       #   Alt 2
 |
 |Note: You will also new to import the new cert. authority.
 |For example on Mac:
 |    Open Keychain Access
 |    Choose "System" in the "Keychains" list
 |    Choose "Certificates" in the "Category" list
 |    Choose "File | Import Items..."
 |    Browse to the file created above, "rootCA.pem", select it, and click "Open"
 ```


### Certificate Formats

* X.509 v3+ ENCODINGS:
  * DER: (Binary) DER == ASN.1 (D)istinguised -vs Basic/Canonical- (E)ncoding (R)ules
  * PEM: (Base64) PEM == (P)rivacy (E)nhanced (M)ail, prefixed with "—– BEGIN ..."
    Default encoding in OpenSSL/ssh/.... Easier to C&P
* Common FILE-EXTENSIONS:
  * *.CRT: Certificates encoded as binary DER/PEM.
  * *.CER: Mostly similar to .CRT, recognized by some Micrsooft apps.
  * *.KEY: used for private PKCS#8 keys encoded as DER/PEM.

* RELATED STANDARDS: PKCS #7, PCKS #12  <#PKCS_summary>
  P7B ASCII files which can contain (non-secret) Certs. and CA certificates.

* PKCS#12: FILE FORMAT commonly used for (PRIVATE)KEYSTORES, protected with
           password-based symmetric key. Used by:
  * Java key store
  * client auth. certs in Firefox, Apache Tomcat, ...
  * "PFX" files.

  ```
  |                                                                      # CONVERTING TO/FROM
  |$ openssl x509 -inform pem -in ${DOMAIN}.crt \                        # PEM   > DER
  |  -outform der -out ${DOMAIN}.der
  |$ openssl x509 -inform der -in ${DOMAIN}.der \                        # DER   > PEM
- |outform pem -out ${DOMAIN}.crt
  |$ openssl crl2pkcs7 -nocrl -certfile ${DOMAIN}.crt \                  # PEM   > PKCS7
  |  -certfile ca-chain.crt -out ${DOMAIN}.p7b
  |$ openssl pkcs7 -in ${DOMAIN}.p7b \                                   # PKCS7 > PEM
  |   -print_certs -out ${DOMAIN}.crt     
  |$ openssl pkcs12 -inkey ${DOMAIN}.key \                               # PEM   > PKCS12
  |   -in ${DOMAIN}.crt -export -out ${DOMAIN}.pfx
  |$ openssl pkcs12 -in ${DOMAIN}.pfx -nodes  \                          # PKCS12 > PEM
  |  -out ${DOMAIN}.combined.crt 
  |$ openssl x509 -in ${DOMAIN}.cer -outform PEM -out ${DOMAIN}.pem      # x509 > PEM
  ```

### Random Recipes

* Generate FINGERPRINT from TLS certificate.<br/>
  CRYPTOG_HASH(public_key) used as ID of pub.keys.
  ```
  |$ openssl x509 -in ${DOMAIN}.crt \
  |  -noout -fingerprint -sha256        
  | fa:23:a4:48:............:56
  ```
* Protect JS from remote changes [[{tech_stack.javascript]]
  ```
  |$ cat jquery-2.1.4.min.js | openssl dgst -sha256 # 
  |> f321e2a........ <·· hexadecimal format           
  |
  |<script src="./jequery-2.1.4.min.js"
  |        integrity="sha256-8WqyJLuWKRB...="> <·· base64 format
  |</script>
  ```
 [[}]]
* fetch 1st-in-chain web cert, then add to Java.KeyStore:                     
  ```
  |$ openssl s_client \
  |   -connect www.mywebsite.com:443 \
  |   -showcerts </dev/null 2>/dev/null | \        VIEW AND VERIFY CS
  |  openssl x509 \                               │$ openssl req \
  |    -outform PEM > infura-morden.pem           │  -text  \  # "view"
  |$ ($JAVA_HOME/Contents/Home/jre/bin/)keytool \ │  -verify \ # "verify"
  |    -import -noprompt -trustcacerts \          │  -noout \
  |    -alias www.mywebsite.com -f                │-in ${DOMAIN}.csr
  ```
* Check version/build
  ```
  | $ openssl version -a
  ```
* LIST SUPPORTED CIPHERS
  ```
  |$ openssl ciphers -s -tls1_3 ← -s -tls1_1: filter for sepcific TLS version
  |> TLS_AES      _256_GCM_SHA384:TLS_AES      _128_GCM_SHA256:...
  ```
* test cipher-suite against serve
  ```
  | $ openssl s_client \              Ex:
  |   -connect domain.com:443 \      Using weak (128bit) cipher will probably fail
  |   -cipher PSK-AES128-CBC-SHA \ ← or -tls1_1 to test TLS supported version.
  |   -quiet -no_tls1_3
  ```
* Verify that cert. was signed by given CA:
  ```
  |$ openssl verify -verbose -CAFile ca.crt ${DOMAIN}.crt
  ```
* Examine Cert. Extension/s
  ```
  | $ openssl x509 \               check Subject Alternative Name(SAN) extension ,
  |   -in ... -noout \             used to associate 1+ values (FQDNs,...) to 1 Cert.
  |   -ext subjectAltName       ←  Also used as alternative to deprecated common name.
  | > X509v3 Subject Alt. Name:    NOTE: Use commas to separate 2+ extensions:
  | >   DNS:*.domi01.com, DNS:...  OTHER WIDELY USED X509 EXTENSIONS INCLUDE:
  |                                · 'basicConstraints'
  |                                · 'keyUsage'  (Can Sign?, Can Sign CRL?...)
  |                                (leave -ext alone to show all extensions in Cert)
  ```

### CRL how-to with OpenSSL

* WARN: Some companies/apps have deprecated CRLs in
  favor of  Online Certificate Status Protocol (OCSP).
  CRL == Cert. list of ALREADY revoked Certs.

  * PRE-SETUP) Set crl_day check period
    ```
    | $ editor .../intermediate/openssl.cnf 
    |  [ CA_default ]
    |  ...
    |  default_crl_days = 30                <·· periodic checking ...
    |  [ server_cert ]
    |  # ... snipped ...
    | *crlDistributionPoints = URI:http...  <·· See man for + crl options
    ```
  * STEP 2: Periodically recreate CLR.
    perioadically according to default_crl_days defined in STEP 1)
    ```
    | $ export CLR_OUTPUT=intermediate/crl/intermediate.crl.pem
    |
    | $ cd ~/ca                           
    | $ openssl ca \
    |   -config intermediate/openssl.cnf \
    |   -gencrl  \                        
    |   -out ${CLR_OUTPUT}
    ```
  * STEP 3: Verify output of STEP 2. 
    ```
    | $ openssl crl \                     
    |   -in ${CLR_OUTPUT} \
    |   -noout -text
    | > ... No Revoked Certificates
    |  (No certificates have been revoked yet)
    ```
  * STEP 4: make CLR_OUTPUT accessible through HTTP URL indicated in STEP 1
    ```
    | NOTE: For servers authenticating clients through X.509 certs,
    |       copy the generated crl file to a path indicated by the server config
    |       ('SSLCARevocationPath' in Apache HTTP, 'crl-verify' in OpenVPN,...)
    ```
  * REVOKE A CERTIFICATE
    ```
    | $ cd ~/ca
    | $ openssl ca \
    |   -config intermediate/openssl.cnf \
    |   -revoke  \
    |   intermediate/certs/bob@example.com.cert.pem
    ```
  * NOTE: CRL distribution points in X.509 Certs visible in X509v3 details.
    ```
    |    # openssl x509 -in ${DOMAIN}.cert.pem -noout -text
    |    ...
    |      X509v3 CRL Distribution Points:
    |
    |          Full Name:
    |            URI:http://domain1.com/intermediate.crl.pem
    |    ...
    ```


[[{monitoring.TLS]]
### check TLS cert.expiration 
<https://www.cyberciti.biz/faq/find-check-tls-ssl-certificate-expiry-date-from-linux-unix/>
  ```
  | $ export server="www.nixcraft.com"
  | $ export port="443"
  |                              **Show validity/expiration dates for CERT**
  |                                =======================================
  | $ echo | \                   ← Avoid pressing CTRL+C
  |   openssl s_client \         ← implements generic TLS network client
  |   -servername $server \      ← Set TLS Ser.NameIndication(SNI)@ClientHello msg
  |   -connect $server:$port  | \
  |   openssl x509 \             ← Run certificate display and signing utility.
  |                                Use '-in file_input.pem' if no STDIN is present.
  |       -noout \               ← Prevent encoded version output
  |       -dates                 ← show also start+expiry dates
  | (Output will be similar to...)
  | depth=2 C = US, O = Inet Sec...Group, CN = ISRG Root X1
  | verify return:1
  | depth=1 C = US, O = Let's Encrypt, CN = R3
  | verify return:1
  | depth=0 CN = www.nixcraft.com
  | verify return:1
  | DONE
  | notBefore=Nov 11 01:15:45 2021 GMT
  | notAfter=Feb  9 01:15:44 2022 GMT
  |
  |                              **Check: expiration date before 4 months**?
  |                                =======================================
  | $ echo | \                   ← Avoid pressing CTRL+C
  |   openssl s_client \         ← implements generic TLS network client
  |   -servername $server \      ← Set TLS Ser.NameIndication(SNI)@ClientHello msg
  |   -connect $server:$port  | \
  |   openssl x509 \             ← Run certificate display and signing utility.
  |                                Use '-in file_input.pem' if no STDIN is present.
  |       -noout \               ← Prevent encoded version output
  |       -enddate \
  |       -checkend 10540800     ← == 4months x 30.5days/m x 24hour/d x 3600 secs/h
  | (Output will be similar to...)
  | ...
  | DONE
  | notAfter=Feb  9 01:15:44 2022 GMT
  | Certificate will expire      ← $? will return 1 (it will expire!)
  ```
[[monitoring.TLS}]]
[[protocol.tls.openssl}]]


## Caddy HTTPS server [[{standards.pki,protocol.TLS,01_PM.low_code,qa.UX,tech_stack.java,01_PM.TODO]]
* <https://caddyserver.com/>
* Caddy simplifies your infrastructure. It takes care of TLS
  certificate renewals, OCSP stapling, static file serving, reverse
  proxying, Kubernetes ingress, and more.
* Its modular architecture means you can do more with a single, static
  binary that compiles for any platform.
* Caddy runs great in containers because it has no dependencies—not
  even libc. Run Caddy practically anywhere.
* https://github.com/AmadeusITGroup/AutoSSL
  Automated SSL certificates monitoring, renewal and deployment from blueprint.
  module for Python 2.7+/3.5+ that can be used to to automate SSL 
  certificate monitoring, renewal and deployment.
* This module can be customized with plugins mechanism to support any type of:
  * server: where the certificate is deployed, can be 1 or more server,
    potentially of different types
  * storage: where to store your artifacts (private key, public
    certificate, ...)
  * tracking mechanism: how to track renewal process (ticket creation)
  * renewal method: how to get a new certificate (local CA, ACME
    protocol, ....)
* AutoSSL in OpenLiberty:
<https://developers.redhat.com/blog/2020/10/07/install-a-signed-certificate-with-open-liberty-20-0-0-10s-automatic-certificate-management-environment-support-2-0/>
* Red Hat Runtimes now supports the new Open Liberty 20.0.0.10 Java
  runtime. Open Liberty 20.0.0.10 features support for the Automatic
  Certificate Management Environment (ACME) protocol, which automates
  the process of obtaining a certificate signed by a certificate
  authority (CA). The Open Liberty 20.0.0.10 release also includes many
  bug fixes.
[[}]]

## Portecle: Cert+Keystore GUI [[{protocol.tls.ca,protocol.TLS,secret_mng.wallet,]]
                               [[ qa.UX,use_case.secret_mng,use_case.signature,tech_stack.java]]
<https://www.sslsupportdesk.com/portecle-advanced-keystore-creation-and-manipulation-tool/>
* user friendly Java GUI: import/create/manage/examine/convert keystores, key-pairs,
  certificates, certificate signing requests, CRL, ...
* Scenario 1: server lacking the capability of generating a CSR keypair on its own.
* Scenario 2: large networks of servers faced with a CSR keypair on one system
              environment that needs key store conversions to it into a different
              environment (ussually very time consuming and frustrating).
* Use Cases examples:
  * Create, load, save, and convert keystores.
  * Generate DSA and RSA key-pair entries with self-signed X.509 certificates.
  * Import X.509 certificate files as trusted certificates.
  * Import key pairs from PKCS#12.
  * Clone and change the password of key pair entries and keystores.
  * View the details of certificates contained within keystore entries.
    certificate files, and SSL/TLS connections.
  * Export keystore entries in a variety of formats.
  * Generate and view certification requests (CSRs).
  * Import Certificate Authority (CA) replies.
  * Change the password of key pair entries and keystores.
  * Delete, clone, and rename keystore entries.
  * View the details of certificate revocation list (CRL) files.
[[}]]

## RFC 8555: PKI using X.509 [[{standards.pki.x509,protocol.TLS.ca,02_doc_has.comparative,01_PM.TODO]]
<https://tools.ietf.org/html/rfc8555>
Published on 2015-05-22 according to
<https://datatracker.ietf.org/doc/rfc8555/>
Public Key Infrastructure using X.509 (PKIX) certificates are used
for a number of purposes, the most significant of which is the
authentication of domain names.  Thus, certification authorities
(CAs) in the Web PKI are trusted to verify that an applicant for a
certificate legitimately represents the domain name(s) in the
certificate.  As of this writing, this verification is done through a
collection of ad hoc mechanisms.  This document describes a protocol
that a CA and an applicant can use to automate the process of
verification and certificate issuance.  The protocol also provides
facilities for other certificate management functions, such as
certificate revocation.
[[}]]

## IETF ACME [[{protocol.tls,standards.pki,qa.automatization,01_PM.TODO]]
<https://tools.ietf.org/html/rfc8555>
* ACME stands for Automatic Certificate Management Environment (ACME) protocol.
* Public Key Infrastructure using X.509 (PKIX) certificates are used
  for a number of purposes, the most significant of which is the
  authentication of domain names.  Thus, certification authorities
  (CAs) in the Web PKI are trusted to verify that an applicant for a
  certificate legitimately represents the domain name(s) in the
  certificate.  As of this writing, this verification is done through a
  collection of ad hoc mechanisms.  This document describes a protocol
  that a CA and an applicant can use to automate the process of
  verification and certificate issuance.  The protocol also provides
  facilities for other certificate management functions, such as
  certificate revocation.
[[}]]

## Certificate Transparency [[{protocol.tls,standards.pki,qa.transparency,01_PM.TODO]]
* <https://www.certificate-transparency.org/>
* Context: No efficient method/protocol was in place before to allows fetching a
  FULL LIST OF ISSUED CERTIFICATES FOR A GIVEN DOMAIN. Any byzantine CA could
  issue malicious certificates to cheat users and spy their (supposely secure)
  encrypted traffic.
* Cert. Transparency is an Open framework for Cert. Auditing.
  Admins and security teams can use it to supervise wrong issues certificates.
* Starting 2018, Google Chrome (and others) will not trust any certificate not
  passing Cert. Transparency requirements.
* Main objectives:
  * Minimize the possibility for a CA to issue a new TLS Cert. for a given domain,
    without domain owner being aware of it.
  * Provide an open auditing system for any domain owner/CA to query if some
    given certificate has been issued by error or maliciously in nearly real time.
  * Protect users from maliciously issued certs.
  * Identify byzantine/maliciously-behaving Certificate Authorities (CAs).

### Definitions:
* Certificate LOGS : Simple network services  keeping CRYPTOGRAPHICALLY
  SECURE AND PUBLICLY AUDITABLE, APPEND-ONLY RECORDS OF CERTIFICATES.
  · Anyone (most probably CAs)  can submit certificates to a log.
* Monitors : publicly run servers that periodically contact all of the log
  servers and watch for suspicious certificates. For example, monitors can tell
  if an illegitimate or unauthorized certificate has been issued for a domain,
  and they can watch for certificates that have unusual certificate extensions
  or strange permissions, such as certificates that have CA capabilities.
* Auditors : lightweight components PERFORMING TWO FUNCTIONS:
  1. verify that logs behave correctly and are cryptographically consistent.
     IF THAT'S NOT THE CASE, THE LOG WILL NEED TO EXPLAIN ITSELF OR RISK BEING
     SHUT DOWN.
  2. verify that a particular certificate appears in a log.
     Particularly important auditing function because the Cert.Transp. framework
     requires that all SSL certificates be registered in a log. If a Cert. has
     not been registered in a log, it’s a sign that the certificate is suspect, and
     TLS clients may refuse to connect to sites that have suspect certificates.
* Trillian: implementation of concepts described in VerifiableDataStructures.pdf
  white paper, which in turn is an extension and generalisation of the ideas
  which underpines <https://certificate-transparency.org>
[[}]]

## LET’S ENCRYPT + ACME PROTOCOL: free+automated+open CA [[{protocol.tls.letsencrypt]]

plus clients (cerbot, "others") to automate provisioning of HTTPS certificates
on HTTP Web servers.
* <https://letsencrypt.org/>
* <https://certbot.eff.org/about/>
* Certbot shell client might be right for you if you:
  * have control over HTTP server.
  * have ability to "sudo" on server.
* PRESETUP:
  Install Certbot (https://certbot.eff.org/) ACME client. Ex:
  ```
  | $ sudo apt install certbot
  | ...
  | The following additional packages will be installed:
  |   python3-acme python3-certbot ... python3-zope.component...
  | Suggested packages:
  |   python3-certbot-apache python3-certbot-nginx
  |   python-certbot-doc python-acme-doc python-mock-doc <··· !!!
  | ...
  | Need to get 785 kB of archives.
  | After this operation, 4207 kB of additional disk space will be used.
  ```
* STEP 0) Just once:
  Agent software interacts with Let’s Encrypt and generates a new
  key pair identifying the local server.<br/>
  LET'S ENCRYPT IDENTIFIES THE SERVER ADMINISTRATOR BY ITS PUBLIC-KEY.

* STEP 1) 
  ```
  | agent -> LetsEncryptCA: what I need to do to prove control/ownership
  |          of example.com?
  |
  | LetsEncryptCA -> agent:  1+ challenges.
  |                          Challenges can be:
  |                          - Provisioning DNS-record under example.com
  |                          - Provisioning HTTP-resource under well-known URI
  |                            on http://example.com/
  |
  | LetsEncryptCA -> agent: new nonce (to be signed by agent  to prove
  |                         controls over key pair).
  | ...
  | agent         -> agent: complete one challenge
  | agent         -> agent: signs nonce with private-key.
  | agent -> LetsEncryptCA: signed-nonce + "validation-ready" event
  | LetsEncryptCA -> Let's-Encrypt-CA: verify signed-nonce
  | LetsEncryptCA -> Let's-Encrypt-CA: verify challenge.
  |                          (by downloading the file for example)
  | LetsEncryptCA -> Let's-Encrypt-CA: agent (its public key) is authorized.
  ```
  STEP 2) 
  ```
  | agent request/renew/revoke certificates for that domain.
  | agent -> LetsEncryptCA:  request/renew/revoke certificates
  |                          by constructing a PKCS#10 Cert.Sign.Req (CSR)
  | LetsEncryptCA -> LetsEncryptCA: Verify CSR signature against authorized
  |                          pub.key.
  | LetsEncryptCA -> agent: New Certificate.
  |
  | (Revocation/renew) works in a similar manner.
  |
  | revocation-information "normal" channels: OCSP.
  |   Relying parties such as browsers can know that they
  |  shouldn’t accept the revoked certificate by "querying"
  |  those channels.
  ```

### cacert.org [[{]]
<http://www.cacert.org>,
* Target: create alternative Non-Profit CA to commercial ones.
* Curiosly TLS certificate is not allowed by major browers.
[[}]]

### make-ca (KISS CA)
<https://github.com/djlucas/make-ca/blob/master/make-ca>
*  Simple scripts around OpenSSL to create a local certificate authority.
[[protocol.tls.letsencrypt}]]

## OCSP: Online Certificate Status Protocol [[{02_doc_has.comparative]]
<https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol>
* Internet protocol used for obtaining the revocation status of an X.509 digital certificate.
* Alternative to Certificate Revocation Lists to addressg problems associated with
  using CRLs in a public key infrastructure (PKI).
* Messages are encoded in ASN.1
* Architecture is "request/response" message based.
* Supported by different web browsers

Comparision to CRLs
* OCSP response contains less data than a typical CRL file
* easier to parse by end client-side libraries
* OCSP discloses to the responder that """a particular
  network host used a particular certificate at a particular time"""
* OCSP lookups can be performed on transaction or authorization level,
  but CRLs must be updated at intervals.
* Basic PKI implementation
  ```
  | participant: Alice  with certificate issued by CA Carol
  | participant: Bob    with certificate issued by CA Carol
  | Carol      : CA
  | 
  | Alice wishes to perform a transaction with Bob.
  | Alice > Bob: Alice pub.key Certificate
  | Bob   > Bob:(concerned that Alice's priv.key is compromised)
  |              creates an 'OCSP-request'
  |                         --------------
  |                         Alice_cert.serial_number
  | Bob   > Carol: OCSP-request
  | Carol > Carol: reads certificate serial number.
  |                Search if serial number is in revocation ddbb
  | Carol > Bob  : Signed OCSP-response with
  |                'good'|'revoked'|'unknown'|'error code'
  |                key signing OCSP-response must be the
  |                original key signing the cert. originally
  |                or another cert. issued by the original CA
  |                that is marked with a certain extension to
  |                flag it as OCSP signing authority.
  | 
  | Bob   > Bob  : verifies Carol's signed response.
  |                (it's supposed that Bob has stored Carol's
  |                 pub.key sometime before this transaction)
  | 
  | Bob   > Alice: ...
  ```
* Protocol details
* OCSP request format supports additional extensions.
* OCSP can be vulnerable to replay attacks,[5] where a signed,
  'good' response is captured by a malicious intermediary and
  replayed to the client at a later date after the subject
  certificate may have been revoked.  A nonce can be included
  to avoid it.
  * Because of high load, most OCSP responders do not use the
    nonce extension to create a different response for each
    request, instead using presigned responses with a validity
    period of multiple days.<br/>
    Thus, the replay attack is a major threat to validation systems
* OCSP can support more than one level of CA chaining/forwarding
  initial OCSP-requests to by delegated path validation (DPV) servers.
  (See Criticisms in original wikipedia article)
* Supported by Internet Explorer, Mozilla Firefox 3+, Safari-macOS.
  Google Chrome disabled OCSP checks by default in 2012
  citing latency and privacy issues and instead uses thei
  own update mechanism to retrieved revoked certificates
[[}]]

## TLS 1.3 [[{]]
* should be used over TLS1.2 whenever possible!!!
* major update to the TLS protocol, with many security enhancements.
* TLS1.3 is different enough that even though the OpenSSL APIs are
  technically API/ABI compatible when TLS1.3 is negotiated, changes in
  the timing of protocol records and of callbacks broke assumptions
  hard-coded into the ‘tls’ module.
[[}]]

[[{protocol.tls}]]

# Best Practices  [[{ $best_patterns ]]
[[{101,qa,tech_stack.java,crypt_symmetric.aes,standards.25519]]
## Common protocol issues
* ciphertext that aren't secured with a MAC
* message that don't include a time-stamp or counter
* protocols that don't use PK for authenticity
* Reuse of Nonces of IVs
* ... many more

## Best Practices, Dont's!!!
* Don't Implement your own algorithms:<br/>
  Cite by Bruce Schneier:
  """ANYONE, FROM THE MOST CLUELESS AMATEUR TO THE BEST CRYPTOGRAPHER,
   CAN CREATE AN ALGORITHM THAT HE HIMSELF CAN'T BREAK"""
  ("Memo to the Amateur Cipher Desginer", 1998)
* Don't Use hard-coded keys, use a Vault service.
  Don't use a Vault when you can use wallet. (that will use an
  internal vault and never expose secrets outside).
* Never use ECB mode. Prefer CBC, better yet CTR or
  GCM<https://en.wikipedia.org/wiki/Galois/Counter_Mode>
  * WARN: ECB is the default mode in JAVA .
  * Ex.: AES is secure , but   pairing it with ECB is insecure .
  * WARN: even GCM has its flaws; encrypting too much data
    with the same key or make a mistake with the IV/nonce,
    can leak key material.  Other modes are free in to
    those leaks.
* Don't use small public key sizes. At least 2048
* Elliptic curve preferable: p-256 or X25519
* Don't use the same private key for encrypting and signing
* Don't reuse the same nonce twice -it will no be a nonce-
* Don’t use old/broken stuff. Non-exhaustive list includes:
  * DES, MD4, MD5, SHA1, RC4, AES-EC
  * RSA is old, but not broken ,  but prefer ECC-mode.
[[}]]

## Universal Composability [[{PM.TODO]]
* <https://en.wikipedia.org/wiki/Universal_composability>
  universal composability (UC)[1] is a general-purpose model for the
  analysis of cryptographic protocols. It guarantees very strong
  security properties. Protocols remain
* <https://en.wikipedia.org/wiki/Commitment_scheme>
  It is impossible to realize commitment schemes in the universal
  composability (UC) framework
[[}]]
[[ $best_patterns }]]

# PKCS standard [[{standards.PKCS,standards.hardware,crypt_asymmetric,secret_mng]]
                 [[use_case.signature]] #[PKCS_summary]
* <https://en.wikipedia.org/wiki/PKCS>

PKCS: Set of "high-level" "Public Key Cryptography Standards":</a>
* PKCS #1  math. properties + format of RSA pub/priv keys, and
           basic algorithms and encoding/padding schemes for RSA
           (de/en)cryption,  producing/verifying signatures.
* PKCS #3  Diffie–Hellman Key Agreement Standard
* PKCS #5  Password-based Encryption Standard
* PKCS #7  Cryptographic Message Syntax used to sign
           and/or encrypt messages under a PKI
           See also (PKCS #7 derived) @:
         <https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax>
           For example when exporting a certificate from a key-store the
           actual certificate chain is exported as in PKCS#7 format.
* PKCS #8  Private-Key Information Syntax Standard. Used to protect priv.cert
           Key (and its matching pub.key), (.pem format)
* PKCS #9  Defines selected attribute types for use in PKCS #6,#7,#8,#10
* PKCS #10 Certification Request Standard file format.
           (for example, generated by $ keytool -certreq ... command)
* PKCS #11 Cryptographic (Athentication) Token Interface   [[[{standards.hardware]]
           ("Cryptoki") API defining a generic interface
           https://en.wikipedia.org/wiki/PKCS_11"
           PKCS #11 defines a common API to be used by     [[{doc_has.comparative]]
           different "hardware", while PKCS #12 defines a common file format. [[}]]
           [[standards.hardware}]]
* PKCS #12  Personal Information Exchange Syntax defining file (.p12 or .pfx file ext.)
            format commonly used to store private keys, protected with a password-based
            symmetric key. Used by:
  * Java key store
  * client auth. certs in Firefox, Apache Tomcat
  * Compared to PKCS#8:
    * PKCS #8  defines what should be included in a private key file.
    * PKCS #12 defines how to package a private key AND ITS CERTIFICATES into a single file.
* PKCS #15 idetification through tokens allowing users to identify
  themselves to applications, independent of the application's Crypto.
  implementation (PKCS #11) or other API
* Note: PCKS#12 .p12, PKCS#8 .pem and Java KeyStore .jks are sort of competing formats.
  Starting with Java 9, the SDK replaces .jks by PCKS#12 as default format for keys.
* See also:
  * ISO 7816 standard for electronic identification cards with 
    contacts, especially smart cards.
    <https://en.wikipedia.org/wiki/ISO/IEC_7816>
[[}]]

## PKCS #11 [[{]]
* PKCS #11 also refers to the platform-independent API to create and
  manipulate cryptographic tokens ( cryptographic keys).
* Underlying platforms can be HSM, Smart Cards, ...
* The API itself is called "Cryptoki" /crypto-key/ for
  (cryp)tographic (tok)en (i)nterface but is also referred to as just
  "PKCS #11" and is defined using ANSI-C standard and ANSI-C headers.
* Cyptoki API defines the most commonly used cryptographic object types:
  (RSA keys, X.509 certificates, ...  DES/Triple-DES keys ...) as well
  as all the functions needed to use, create/generate, modify and
  delete those objects.

* PCKS #11 Usage:
  Most commercial certificate authority (CA) software uses PKCS #11 to
  access the CA signing key[clarification needed] or to enroll user
  certificates. Cross-platform software that needs to use smart cards
  uses PKCS #11, such as Mozilla Firefox and OpenSSL (through extension).

* PCKS #11 and KMIP Relationship:
  Key Management Interoperability Protocol (KMIP) defines a **wire
  protocol** with similar functionality to PKCS#11 API.
  * Originally developed independently and overlapping, thery are now
    both governed by an OASIS technical committee with the aim to
    align both of them when practicable.
    e.g: PKCS#11 Sensitive and Extractable attributes
    are being added to KMIP v.1.4.

* PCKS #11 History
  ```
  1994-01: project launched by RSA Security Company
  1995-04: v1.0
  1997-12: v2.01
  1999-12: v2.10
  2001-01: v2.11
  2004-06: v2.20[1]
  2005-12: amendments 1&2 (one-time password tokens, CT-KIP [3])
  2007-01: amendment 3 (additional mechanisms)
  2009-09: v2.30 draft published for review
           (final version never published)
  2012-12: RSA announce PKCS #11 management being transitioned to OASIS
  2013-03: v2.40 work starts [5]
  2015-04: v2.40 spec approved
  2016-05: v2.40 Errata 01 Spec approved
  2020-07: v3.0  spec approved
  ```

### PCKS #11 v3 Cryptoki summary:
* [Cyrptoki base API](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) [[{]]
  ```
  | GENERAL PURPOSE FUNCTIONS  ──────────────────────────────────────────────────────────────
  |   C_Initialize              initializes Cryptoki
  |   C_Finalize                clean up miscellaneous Cryptoki-associated resources
  |   C_GetInfo                 obtains general information about Cryptoki
  |   C_GetFunctionList         obtains entry points of Cryptoki library functions
  |   C_GetInterfaceList        obtains list of interfaces supported by Cryptoki library
  |   C_GetInterface            obtains interface specific entry points to library functions
  | SLOT AND TOKEN MANAGEMENT FUNCTIONS  ────────────────────────────────────────────────────
  |   C_GetSlotList             obtains a list of slots in the system
  |   C_GetSlotInfo             obtains information about a particular slot
  |   C_GetTokenInfo            obtains information about a particular token
  |   C_WaitForSlotEvent        waits for a slot event (token insertion, removal, etc.)
  |   C_GetMechanismList        obtains a list of mechanisms supported by a token
  |   C_GetMechanismInfo        obtains information about a particular mechanism
  |   C_InitToken               initializes a token
  |   C_InitPIN                 initializes the normal user’s PIN
  |   C_SetPIN                  modifies the PIN of the current user
  | SESSION MANAGEMENT FUNCTIONS  ───────────────────────────────────────────────────────────
  |   C_OpenSession             opens a connection between an application and a particular
  |                             token or sets up an application callback for token insertion
  |   C_CloseSession            closes a session
  |   C_CloseAllSessions        closes all sessions with a token
  |   C_GetSessionInfo          obtains information about the session
  |   C_SessionCancel           terminates active session based operations
  |   C_GetOperationState       obtains the cryptographic operations state of a session
  |   C_SetOperationState       sets the cryptographic operations state of a session
  |   C_Login                   logs into a token
  |   C_LoginUser               logs into a token with explicit user name
  |   C_Logout                  logs out from a token
  | OBJECT MANAGEMENT FUNCTIONS ─────────────────────────────────────────────────────────────
  |   C_CreateObject            creates an object
  |   C_CopyObject              creates a copy of an object
  |   C_DestroyObject           destroys an object
  |   C_GetObjectSize           obtains the size of an object in bytes
  |   C_GetAttributeValue       obtains an attribute value of an object
  |   C_SetAttributeValue       modifies an attribute value of an object
  |   C_FindObjectsInit         initializes an object search operation
  |   C_FindObjects             continues an object search operation
  |   C_FindObjectsFinal        finishes an object search operation
  | ENCRYPTION FUNCTIONS  ───────────────────────────────────────────────────────────────────
  |   C_EncryptInit         initializes an encryption operation
  |   C_Encrypt             encrypts single-part data
  |   C_EncryptUpdate       continues a multiple-part encryption operation
  |   C_EncryptFinal        finishes a multiple-part encryption operation
  | MESSAGE-BASED ENCRYPTION FUNCTIONS  ─────────────────────────────────────────────────────
  |   C_MessageEncryptInit  initializes a message-based encryption process
  |   C_EncryptMessage      encrypts a single-part message
  |   C_EncryptMessageBegin begins a multiple-part message encryption operation
  |   C_EncryptMessageNext  continues or finishes a multiple-part message encryption operation
  |   C_MessageEncryptFinalfinishes a message-based encryption process
  | DECRYPTION FUNCTIONS   ──────────────────────────────────────────────────────────────────
  |   C_DecryptInit         initializes a decryption operation
  |   C_Decrypt             decrypts single-part encrypted data
  |   C_DecryptUpdate       continues a multiple-part decryption operation
  |   C_DecryptFinal        finishes a multiple-part decryption operation
  | MESSAGE-BASED DECRYPTION FUNCTIONS  ─────────────────────────────────────────────────────
  |   C_MessageDecryptInit  initializes a message decryption operation
  |   C_DecryptMessage      decrypts single-part data
  |   C_DecryptMessageBegin starts a multiple-part message decryption operation
  |   C_DecryptMessageNext  Continues and finishes a multiple-part message decryption operation
  |   C_MessageDecryptFinal finishes a message decryption operation
  | MESSAGE DIGESTING FUNCTIONS ─────────────────────────────────────────────────────────────
  |   C_DigestInit          initializes a message-digesting operation
  |   C_Digest              digests single-part data
  |   C_DigestUpdate        continues a multiple-part digesting operation
  |   C_DigestKey           digests a key
  |   C_DigestFinal         finishes a multiple-part digesting operation
  | SIGNING FUNCTIONS ────────────────────────────────────────────────────────────────────────
  |   C_SignInit            initializes a signature operation and MACing
  |   C_Sign                signs single-part data
  |   C_SignUpdate          continues a multiple-part signature operation
  |   C_SignFinal           finishes a multiple-part signature operation
  |   C_SignRecoverInit     initializes a signature operation, where the data can be recovered from the signature
  |   C_SignRecover         signs single-part data, where the data can be recovered from the signature
  | MESSAGE-BASED SIGNATURE FUNCTIONS  ──────────────────────────────────────────────────────
  |   C_MessageSignInit     initializes a message signature operation
  |   C_SignMessage         signs single-part data
  |   C_SignMessageBegin    starts a multiple-part message signature operation
  |   C_SignMessageNext     continues and finishes a multiple-part message signature operation
  |   C_MessageSignFinal    finishes a message signature operation
  | FUNCTIONS FOR VERIFYING SIGNATURESAND MACS  ─────────────────────────────────────────────
  |   C_VerifyInit          initializes a verification operation
  |   C_Verify              verifies a signature on single-part data and MACs
  |   C_VerifyUpdate        continues a multiple-part verification operation
  |   C_VerifyFinal         finishes a multiple-part verification operation
  |   C_VerifyRecoverInit   initializes a verification operation where the data is recovered from the signature
  |   C_VerifyRecover       verifies a signature on single-part data, where the data is recovered from the signature
  | MESSAGE-BASED FUNCTIONS FOR VERIFYING SIGNATURES AND MACS  ──────────────────────────────
  |   C_MessageVerifyInit   initializes a message verification operation
  |   C_VerifyMessage       verifies single-part data
  |   C_VerifyMessageBegin  starts a multiple-part message verification operation
  |   C_VerifyMessageNext   continues and finishes a multiple-part message verification operation
  |   C_MessageVerifyFinal  finishes a message verification operation
  | DUAL-PURPOSE CRYPTOGRAPHIC FUNCTION  ────────────────────────────────────────────────────
  |   C_DigestEncryptUpdate continues simultaneous multiple-part digesting  and encryption   ops
  |   C_DecryptDigestUpdate continues simultaneous multiple-part decryption and digesting    ops
  |   C_SignEncryptUpdate   continues simultaneous multiple-part signature  and encryption   ops
  |   C_DecryptVerifyUpdate continues simultaneous multiple-part decryption and verification ops
  | KEY MANAGEMENT FUNCTIONS ────────────────────────────────────────────────────────────────
  |   C_GenerateKey         generates a secret key
  |   C_GenerateKeyPair     generates a public-key/private-key pair
  |   C_WrapKey             wraps (encrypts) a key
  |   C_UnwrapKey           unwraps (decrypts) a key
  |   C_DeriveKey           derives a key from a base key
  | RANDOM NUMBER GENERATION FUNCTIONS ─────────────────────────────────────────────────────
  |   C_SeedRandom          mixes in additional seed material to the random number generator
  |   C_GenerateRandom      generates random data
  | Parallel function management functions ─────────────────────────────────────────────────
  |   C_GetFunctionStatus   legacy function which always returns CKR_FUNCTION_NOT_PARALLEL
  | C_CancelFunction        legacy function which always returns CKR_FUNCTION_NOT_PARALLEL
  | CALLBACK FUNCTION  ────────────────────────────────────────────────────────────────
  |   "xxxx"                application-supplied function to process notifications from Cryptoki
  ```
[[}]]
* [profiles](https://docs.oasis-open.org/pkcs11/pkcs11-profiles/v3.0/os/pkcs11-profiles-v3.0-os.html)
  * Baseline Consumer/Provider
  * Extender Consumer/Provider/ Authentication Token Clause, Public Certificates Token Clause
* [historical](https://docs.oasis-open.org/pkcs11/pkcs11-curr/v3.0/os/pkcs11-curr-v3.0-os.html)
* [historical](https://docs.oasis-open.org/pkcs11/pkcs11-hist/v3.0/os/pkcs11-hist-v3.0-os.html)
[[}]]

# OpenGPG Standard [[{standards.pgp]]
[[{secret_mng,tool.gpg,tech_stack.git,secret_mng.keystore,crypt_symmetric,crypt_asymmetric,use_case.signature]]
## OpenPGP Summary
* PGP: Pretty Good Privacy: encryption program (1991 Phil Zimmermann)
       Used for signing, encrypting, and decrypting texts, e-mails,
       files, directories, disks, e-mails.
* OpenPGP: Open Standard around PGP software (RFC 4880)
* GPG: Gnu Privacy Guard implementation

## Symmetric file encryption
* simpler and more secure than asym. one.
* Can NOT be used to publish with anonymous or untrusted users.
  For example, it can NOT be used to cypher (or sign) content in
  public software repositories since there is no way to distribute the
  private key to future and unknown/untrusted recipients.
* In can be used to store secrets safely in private repositories like git.
* Ex Ussage:
  * PRE-SETUP :
    "master key" : Private key that git team keeps secret (ideally "memorized")
    Different master keys can be used in different contexts.
    ```
    | $ ls secrets.txt*
    | secrets.txt                              ← Secrets to access login, resources, ddbbs,...
    |                                             add to .gitignore  to avoid distributing secrets
    |
    | $ cat secrets.txt \
    |     | gpg -c --batch --passphrase $pass\   ← Generates binary encrypted output Q *1
    |     | base64 \                             ← (optional): Allows to copy in mail/stdin/...
    |     > secrets.txt.gpg.base64
    |       └───────┬────────────┘
    |       Can be added to git : Each time "master key" is
    |       rotated, this file must be regenerated (and old
    |       master key used in the mean time to decrypt).
    |
    | $ cat secrets.txt.gpg.base64 \
    |     | base64 -d \
    |     | gpg -d --batch --passphrase $pass \    Q *1
    |     > secrets.txt
    |
    | Q *1 : Remove --batch --passphrase options to ask for password interactively.
    |        (probably safer, but can not be scripted easily)
    ```
   * SAFE CLEAN-UP :
    ```
    | $ shred -n 2 -z -v secrets.txt   ← safe/secure deletion. Standard
    |                                    "rm" leaves original bytes in the
    |                                    hard-disk
    ```

### GPG: managing pub/priv. keys

* Before signing and encripting we need to learn how to create/import/export PGP keys.
  REF:<http://central.sonatype.org/pages/working-with-pgp-signatures.html>

  ```
  | $ gpg --gen-key                 ← Create new key pair defs: RSA 2048bit, no-expire
  | #                                     (enter name,email                      ^^^^^^^^^
  |                                         when prompted)           Recommended <=2 years
  |                                                        Once expired it can be extended
  |                                                        providing  key (and passphrase)
  |
  | $ gpg2 --list-keys              ←  LIST ALL PUB. KEYS (ours and imported/pulled)
  | /home/juven/.gnupg/pubring.gpg
  | ------------------------------
  | pub   1024D/C6EED57A 2010-01-13  ← Seed key
  | uid   ...<old.mcdonalds@farm.com>
  | sub   2048g/D704745C 2010-01-13  ← Sub.signing key
  |       └─┬─┘ └──┬───┘
  |      length   key id
  |
  | $ gpg2 --list-secret-keys        ← LIST PUBLIC KEYS FROM OUR PRIVATE KEYS
  | /home/juven/.gnupg/secring.gpg
  | ------------------------------
  | sec   1024D/C6EED57A 2010-01-13  ← Seed key
  | uid   ...<old.mcdonalds@farm.com>
  | ssb   2048g/D704745C 2010-01-13  ← Sub.signing key
  |
  | KEYSERVER="hkp://pool.sks-keyservers.net"
  | ┌──────────────────────────────────┬───────────────────────────────────┐
  | │         "PUSH" PUB.KEY           │           "PULL" PUB.KEY          │
  | ├──────────────────────────────────┼───────────────────────────────────┤
  | │$ gpg2 --keyserver ${KEYSERVER} \ │ $ gpg2 --keyserver ${KEYSERVER} \ │
  | │$     --send-keys B C6EED57A      │ $     --recv-keys C6EED57A        │
  | └──────────────────────────────────┴───────────────────────────────────┘
  |
  | $ gpg2 --edit-key A6BAB25C       ←  MODIFY KEY
  |   ... Secret key is available.
  |   pub  2048R/A6BAB25C  created: ...  expires: ...
  |        trust: ultimate      validity: ultimate
  |   sub  2048R/DD289F64  created: ...  expires: ...
  |        Juven Xu (for testing) <test@juvenxu.com>
  |   ...
  |   gpg>   1   # ← Choose key
  |   pub  2048R/A6BAB25C  created: ...  expires: ...  usage: SC
  |        trust: ultimate      validity: ultimate
  |   sub  2048R/DD289F64  created: ...  expires: ...  usage: E
  |   (1)* Juven Xu (for testing) <test@juvenxu.com>
  |
  |   gpg>   expire                     ←  EXPIRE A KEY
  |   > ...
  |   > Please specify how long the key should be valid.
  |           0 = key does not expire
  |         <n> = key expires in n days
  |        ...
  |   gpg>   save                       ← send key ("push") to sync changes remotely
  ```

* Troubleshooting problems with Maven and others:
  mvn and some other app will only recognise the primary key,
  ignoring subkeys. A "patch" solution consists in deleting
  the  singing subkey forcing GPG to use the primary key.
  ```
  | $ gpg2 --edit-key A6BAB25C       ←  MODIFY KEY
  | ...
  | pub  2048R/A6BAB25C  created:... usage: SC   ← Seed Key.   Only key recognised by maven and others
  |      trust: ultimate validity: ultimate
  | sub  2048R/DD289F64  created:...  usage: E   ← Default (E)ncryption key
  | sub  2048R/8738EC86  created:...  usage: S   ← Default (S)igning    key
  |                                                (  Must be removed to use maven pgp plugin   )
  | gpg>   key 2  (index start at 0)               (Not needed if using gpg from comand line)
  | ...                                               │
  | gpg>   delkey   ← Alt 1: Key not yet published  ←─┘
  | gpg>   revoke   ← Alt 2: Key already published
  | gpg>   save
  | -------------------------------------------------

  | *****************
  | * Signing files *
  | *****************
  | $ gpg2 -ab temp.java            ←  SIGNING A FILE
  |                                   -a create ASCII armored output
  |                                   -b make detached signature
  | $ gpg2 --verify temp.java.asc   ←  Verify new signature
  ```


### GPG Advanced (Symmetric) multi-level file encryption

* Bell–LaPadula Model:
  <https://en.wikipedia.org/wiki/Bell%E2%80%93LaPadula_model>
  ```
  Level 3 user have passwords to encrypt/decrypt level     3
  level 2 user have passwords to encrypt/decrypt level   2,3
  level 1 user have passwords to encrypt/decrypt level 1,2,3
  ```

  ```
  | $ LEVEL1=level1Ciphered.base64 ; DECODE_LEVEL1=decodedlevel1 ;
  | $ LEVEL2=level2Ciphered.base64 ; DECODE_LEVEL2=decodedlevel2 ;
  | $ LEVEL3=level3Ciphered.base64 ; DECODE_LEVEL3=decodedlevel3 ;
  | 
  | $ GPG_C="gpg -c --batch --passphrase " # Encode
  | $ GPG_D="gpg -d --batch --passphrase " # Decode
  |
  | # Encode
  | $ (                 echo "secrets level 1" ) | ${GPG_C} ${PASS_LEVEL1} | base64 > ${LEVEL1}
  | $ ( cat ${LEVEL1} ; echo "secrets level 2" ) | ${GPG_C} ${PASS_LEVEL2} | base64 > ${LEVEL2}
  | $ ( cat ${LEVEL2} ; echo "secrets level 3" ) | ${GPG_C} ${PASS_LEVEL3} | base64 > ${LEVEL3}
  | 
  | # Decode
  | $ cat ${LEVEL3} | base64 -d | ${GPG_C} ${PASS_LEVEL1} >   ${LEVEL2} 
  | $ cat ${LEVEL2} | base64 -d | ${GPG_C} ${PASS_LEVEL2} >   ${LEVEL1} 
  | $ cat ${LEVEL1} | base64 -d | ${GPG_C} ${PASS_LEVEL3} >  PLAIN_TEXT 
  ```
[[secret_mng}]]

[[{standards.pgp,tool.gpg,use_case.signature,crypt.linked_data_signature,01_PM.TODO]]
## OpenPgpSignature2019
* <https://github.com/decentralized-identity/OpenPgpSignature2019>
* OpenPGP is a standard that defines formats for encryption keys and
  messages. By providing a Linked Data Signature suite that uses
  OpenPGP we can leverage a more established standard to support an
  emerging one (Linked Data Signatures). A Linked Data Signature Suite
  for OpenPGP also enables OpenPGP to be used as a building block for
  other standards, such as Decentralized Identifiers.
* This signature suite follows the approach taken by:
  * Ed25519Signature2018  :
  * RsaSignature2017
  * EcdsaKoblitzSignature2016
* cli Ussage example:
  * Sign a json document:
  ```
  | $ openpgpsignature2019 sign -u "3AF00854CF8D9237" \
  |   $(pwd)/src/__tests__/__fixtures__/documents/example.json \
  |   did:btcr:xxcl-lzpq-q83a-0d5#yubikey
  ```
  * Verify a document:
  ```
  | $ openpgpsignature2019 verify $(pwd)/src/__tests__/__fixtures_\
  |   _/documents/exampleSigned.json
  ```
* library ussage example:
  ```
  | const keys = await OpenPgpSignature2019.generateKey({....})
  | const signedData = await OpenPgpSignature2019.sign(
  |     { data: jsonDoc,
  |       privateKey: keys.privateKey,
  |       proof: {
  |         verificationMethod: "https://example.com/i/alice/keys/1",
  |         proofPurpose: "assertionMethod"
  |       }
  |     });
  |
  | const verified = await OpenPgpSignature2019.verify({
  |   data: signedData,
  |   options: ...
  | });
  ```
[[}]]

## Keybase ("GPG++") [[{standards.pgp,tech_stack.keybase,use_case.identity]]
                     [[use_case.signature,qa.UX,01_PM.TODO]]
* <https://julien.ponge.org/blog/simpler-gnupg-with-another-look-at-keybase/>
* Keybase essentially introduced a modern way to build trust networks, because
  people can check that user123 on Keybase is also user123_coder on GitHub,
  user123 on Twitter, and that the user owns the iamuser123.org domain. One can
  do so by posting Keybase-signed messages to these social networks and places.
  This is a good idea, because from social networks and Keybase accounts linked
  to those social networks, you can build a trust network on Keybase.
* Keybase provides a simplified workflow for common tasks including public key
  management (e.g., fetching keys of your contacts), and it has GnuPG
  interoperability. You may even make the devilish (read: convenient) choice of
  having your keys stored on Keybase, or just attach existing GnuPG keys that you
  will still manage locally.
* <https://github.com/tldr-pages/tldr/blob/master/pages/common/keybase.md>  [TODO]
  More info at: <https://keybase.io/docs/command_line>
[[}]]

## guncat (Gpg UNencrypting CAT) [[{qa.UX]]
* REF: <https://fbb-git.gitlab.io/guncat/>
* designed to tackle problems with (partially) PGP encrypted files
   e.g. mailboxes. Tools to process text-files (like grep(1), or less(1)) may be
  used to process those files, but standard tools like cat(1) leave PGP
  encrypted sections within such files as-is. As a consequence, browsing the
  `real' contents (i.e., clear-text sections and the unencrypted contents of PGP
  encrypted sections) of those files is difficult.
* Guncat  acts like cat, but unencrypts encrypted sections encountered in
  the files processed by guncat, copying the unencrypted  information  to
  guncat's  standard  output  stream, which may thereupon be processed by
  other tools.
[[}]]

## Sequoia Implementation [[{PM.TODO]]
* <https://sequoia-pgp.org/>
* Open PGP library focusing on safety and correctness.
[[}]]

## OpenPGP.js [[{standards.pgp,tech_stack.javascript,01_PM.TODO]]
<https://github.com/openpgpjs/openpgpjs>
JavaScript implementation of the OpenPGP protocol defined in RFC 4880.
* a/symmetric (En/de)crypt Uint8Array with PGP key/password.
* Encrypt with compression
* Data Streaming support.
* key pair generation / revocation.
* "Push"/"pull"  public keys from HKP server
* Sign/verify cleartext/Uint8Array stream messages
  (detach signature support)
[[}]]
[[}]]

# Other Standard Protocols
## One Time Password OTP  [[{101,]]
* https://en.wikipedia.org/wiki/One-time_password
* also known as a one-time PIN, one-time authorization code (OTAC)
  or dynamic password, is a password that is valid for only one login
  session or transaction.
* OTP algorithms implementations vary greatly.
* OTPs avoid several shortcomings that are associated with traditional
  (static) password-based authentication, for example not being
  not vulnerable to replay attacks.
* a number of implementations also incorporate two-factor authentication
* Very briefly, OTP algorithms makes use of (pseudo)randomness to
  generate a shared key or seed, and cryptographic hash functions,
  which can be used to derive a value but are hard to reverse and
  therefore difficult for an attacker to obtain the data that was
  used for the hash. This is necessary because otherwise, it would
  be easy to predict future OTPs by observing previous ones.
* CONS:
  * OTPs can be intercepted or rerouted, and hard tokens can get lost,
    damaged, or stolen.
* OTP Standard implmentations include:
  * RFC 1760 (S/KEY)
  * RFC 2289 (OTP)
  * RFC 4226 (HOTP)
  * RFC 6238 (TOTP)
[[}]]

## Signal Protocol (Telegram, Whatsapp,...) [[{]]
* What Is the Signal Encryption Protocol? 
  <https://www.wired.com/story/signal-encryption-protocol-hacker-lexicon/>
[[}]]

## S/MIME [[{standards.S/MIME,protocol,01_PM.TODO]]
* Uses Crypto.Message (PKCS#7) and pub.key infraestructure for encryption and signing
* https://www.infoq.com/news/2018/05/efail-pgp-smime-vulnerability
  PGP/SMIME EFail vulneravility.
[[}]]

## OTR [[{use_case.aaa]]
* OTR stands for Off-The-Record Messaging
<https://en.wikipedia.org/wiki/Off-the-Record_Messaging>
* protocol for securing/authentication/encrypting instant messaging
  communication amongst people.
  Encrypts messages, prevents eavesdroppers, authenticates peers to each other.
  It also provides OTR provides forward secrecy and malleable encryption.
* OTR uses a combination of AES 128bits sym-key algorithm,
  1536-bits group-size Diffie–Hellman and the SHA-1 hash function.
* The primary motivation behind the protocol was providing deniable
  authentication for the conversation participants while keeping
  conversations confidential, like a private conversation in real life, or
  off the record in journalism sourcing. This is in contrast with
  cryptography tools that produce output which can be later used as a
  verifiable record of the communication event and the identities of the
  participants. The initial introductory paper was named "Off-the-Record
  Communication, or, Why Not To Use PGP".[1]
* The OTR protocol was designed by cryptographers Ian Goldberg and Nikita
  Borisov and released on 26 October 2004.[2] They provide a client library
  to facilitate support for instant messaging client developers who want to
  implement the protocol. A Pidgin and Kopete plugin exists that allows OTR
  to be used over any IM protocol supported by Pidgin or Kopete, offering an
  auto-detection feature that starts the OTR session with the buddies that
  have it enabled, without interfering with regular, unencrypted
[[}]]

## Dmarc sec mail [[{protocol.email.dmarc,standards.compliance]]
* <http://www.eweek.com/security/dmarc-email-security-adoption-soars-as-us-government-deadline-hits>]
*  DMARC: protocol protecting integrity and authenticity of email.
   It is the result of combining several components, including:
   * Sender Policy Framework (SPF) + Domain Keys Identified Email (DKIM):
     to help verify email authenticity.
* There are also different levels of DMARC policies:
  * "p=none"   policy: enables organizations to monitor their email systems
                       for senders,
  * "p=reject" policy: block non-compliant messages completely.
* BOD 18-01 mandates the use of the p=reject policy by Oct.16.    [compliance]
  [[}]]

## WebCrypto API [[{]]
browser API for efficient and secure delivery of cryptographic primitives.
* low-level ciphers.
* hashes
* "other" encryption components.
  Being directly implemented into (trusted) browser and taking advantage of
  local native execution and even hardware acceleration) they are much 
  safer than js code. [[{02_doc_has.comparative}]]<br/>
  WARN: They do NOT prevent certain attacks, like just sending an
  unencrypted copy of the data to the "bad guys".
* See also notes about "Trusted web code".
[[}]]

## BaseLine Protocol [[{PM.TODO]]
* Normally zk-SNARKs are used as a way to say "I have a secret" to
  someone and prove that you indeed have the secret without telling
  them what the secret is.
  What the Baseline Protocol uses it for is a little different.
  It's more like saying to a specific set of counterparties,
  "We have a secret" and using a machine that we all can access
  to tell us that we all have the same secret (or that we do
  not) without telling that machine anything that would let someone
  else with access to it discover anything about the secret...or even
  that we have one.
[[}]]

## Universal Second Factor (U2F) [[{standards,101,use_case.AAA,01_PM.TODO]]
* <https://en.wikipedia.org/wiki/Multi-factor_authentication>

### Security token [[{use_case.AAA,hardware,secret_mng]]
* <https://en.wikipedia.org/wiki/Security_token>
* Physical devices used to gain access to an
  electronically restricted resource
* Used in addition to or in place of a password like a
  wireless keycard to open/unlock doors,...
* All tokens contain some secret information used to
  prove identity
* There are four ways in which this info. can be used:
  * Static password: token containing a password
    transmitted for each authentication (vulnerable to
    replay attacks)
  * Syncrhonous dynamic password</def> token, using a
    timer to rotate through various combinations. Need
    time synchronization with server
  * Asyncrhonous password</def> token generating One-time
    password (no clock involved)
  * Challenge-response</def> token using pub.key
    cryptography
[[}]]

## Yubikey [[{use_case.AAA,hardware,01_PM.TODO]]
* <https://www.yubico.com/products/yubikey-hardware/>
* <https://github.com/drduh/YubiKey-Guide>
* ""the industry's #1 security key, enabling strong
  two-factor (2FA), multi-factor and passwordless authentication."""
* Works with hundreds of services incluing Windows/Mac login,
  Gmail, Dropbox, Facebook, Salesforce, Duo, ...
* Multi-protocol support: FIDO2, U2F, Smart card, OTP
[[}]]

### Yubico u2f
* <https://www.yubico.com/solutions/fido-u2f/>
* internet open auth. enabling users to securely access services
  with one single sec.key and with no drivers or client software needed
* u2f at github.com/google:
  <https://github.com/google?utf8=%E2%9C%93&q=u2f&type=&language=>
* See also: Universal Authentication Framework (UAF) protocol:
  * vision: "take strong public key crypto to the mass market"  [[qa.UX]]
  * Successfully deployed by Facebook, Gmail, Dropbox, GitHub, Salesforce.com,
    the UK government, and many more.
[[}]]

## X.509 TimeStamp Protocol [[{crypt_oneway.hash,use_case.non_repudability,]]
                            [[use_case.proof-of-existence,standards.pki.x509]]
* <https://tools.ietf.org/html/rfc3161>
* RFC describes format for request and responses sent to a
  Time Stamping Authority (TSA)
* It establishes several security-relevant requirements for TSA
   operation
* TSA service:
  * provides proof-of-existence:
    * Some data datum existed before a particular time.
      (only the hash representation is used by the protocol)
  * Can also be used as the base for Non-repudiation services [ISONR]
  * only time-stamp a hash representation of the datum, i.e., a
  * CAs will issue custom certificates for this service indicating
    that it is exclusively used for this TSA purpose

REF: 2.2. TSA Transactions
  ```
  | A > TSA: request1
  |          --------
  |          type:TimeStampReq
  | 
  | TSA > A: response1
  |          ---------
  |          TimeStampResp
  |            TimeStampToken(TST)
  | 
  | A >   A:- verify status error
  |         - verify fields contained in the TimeStampToken
  |         - verify validity of digital signature
  |         - verify that what was time-stamped corresponds
  |            to what was requested
  |         - verify that the TimeStampToken contains:
  |           - the correct certificate identifier of the TSA
  |           - the correct data imprint
  |           - the correct hash algorithm OID.
  |         - verify time included in the response against
  |           local trusted time reference
  ```

See original RFC for extended details
[[}]]

# Cryptography Quality Assurance Projects [[{qa]]
## Project Everest [[{tech_stack.f*,qa.formal_proofs,01_PM.low_code,01_PM.TODO]]
* <https://project-everest.github.io/>

Combination of several sub-projects:
* F*, a verification language for effectful programs
* miTLS, reference implementation of the TLS protocol in F*
* KreMLin, a compiler from a subset of F* to C
* HACL*, a verified library of cryptographic primitives written in F*
* Vale, a domain-specific language for verified cryptographic
  primitives in assembly
* EverCrypt, a verified crypto provider that combines HACL* and Vale
  via an agile, multi-platform, self-configuring cryptographic API.
* EverParse, a library and tool to automatically generate verified
  parsers and serializers for binary data formats

* introduced in <https://eprint.iacr.org/2020/572>
* Using F* (<https://www.fstar-lang.org/>)formally probed language
  for implementation of cryptographic primitives (otherwise
  extremely difficult and error prone to implement in C/Rust/...).
* formally-verified Curve25519, ChaCha20, Poly1305,
  P256 elliptic curve for ECDSA and ECDH, GCM, P384/P521 elliptic
  curves, ECDSA signature scheme,...
* Performance close to native assembler manual implementation
* Fiat-Crypto project:
  <http://adam.chlipala.net/papers/FiatCryptoSP19/FiatCryptoSP19.pdf>
* Used in newer versions of Chrome/Firefox/...
* See also:
* Formally Verified Cryptographic Web Applications in WebAssembly
https://www.computer.org/csdl/proceedings-article/sp/2019/666000b002/19skg8v5fZS
[[}]]


## Think lib: crypto for non-experts
[[{qa.UX,01_PM.low_code,tech_stack.android,tech_stack.java,secret_mng.keystore]]
<https://www.infoq.com/news/2018/09/google-tink-cryto-ios-android>
* Crypto.libr for *non cryptographic experts
* cross-platform
* developed by experts to help developers implement cryptography
  correctly  without being cryptographic experts .
* version 1.2 adds support for Cloud, Android, and iOS platforms,
  C++ and Objective-C.
* stress cryptographic libraries against known attacks:
  * biased nonces
  * invalid curves
  * ...
* Tink provides support for key management
  including key versioning/rotation/remote key management systems(KMS):
  * Currently, the following KMSes are supported:
    Google Cloud KMS, Amazon KMS, Android Keystore, Apple iOS KeyChain (planned)
* ensure crypto.algorithms behave as expected (DSA, RSA, AES-EAX, ...)
* Tink strives to make as explicit as possible what security guarantees each
  provided API gives:
  * For example, if a given operation is safe against chosen-ciphertext attacks,
    this is displayed in the interface and that same guarantee has to be satisfied
    by each primitive used to implement it.
* currently four cryptographic operations are provided, implemented by specific primitives:
  * authenticated encryption with associated data (primitive: AEAD)
  * message authentication codes (primitive: MAC),
  * digital signatures (primitives: PublicKeySign and PublicKeyVerify)
  * hybrid encryption (primitives: HybridEncrypt and HybridDecrypt).
* Each operation has an associated set of minimal properties and a guarantee.
  A primitive can have multiple implementations and the user chooses the actual
  implementation to use by instantiating a key of a corresponding type.
[[}]]

## Hyperledger Ursa library [[{01_PM.low_code,01_PM.TODO]]
* <https://www.hyperledger.org/use/ursa>
* Hyperledger Ursa is a shared cryptographic library, it enables
  implementations to avoid duplicating other cryptographic work and
  hopefully increase security in the process. The library is an opt-in
  repository (for Hyperledger and non Hyperledger projects) to place
  and use crypto. Hyperledger Ursa consists of sub-projects, which are
  cohesive implementations of cryptographic code or interfaces to
  cryptographic code.
[[}]]

## Java 21 Key Ecapsulation Mechanism API [[{]]
* <https://www.infoq.com/news/2023/07/modern-cryptography-on-openjdk/>
* JEP 452, Key Encapsulation Mechanism API, has been promoted from 
  Targeted to Completed for JDK 21. This JEP introduces an API for Key 
  Encapsulation Mechanisms (KEMs), a modern encryption technique for 
  securing symmetric keys using public key cryptography. The new API 
  aims to enable applications to use KEM algorithms such as RSA Key 
  Encapsulation Mechanism (RSA-KEM), Elliptic Curve Integrated 
  Encryption Scheme (ECIES), and candidate KEM algorithms for the 
  National Institute of Standards and Technology (NIST) Post-Quantum 
  Cryptography standardization process.
[[}]]

## Azure Sphere Pluton IoT [[{secret_mng.hardware,use_case.IoT,secret_mng.keystore,01_PM.TODO]]
* <https://azure.microsoft.com/en-us/services/azure-sphere/>
* Solution for creating highly secured, connected MCU-powered devices.
* The Pluton security subsystem creates a hardware root of trust,
  stores private keys, and executes complex cryptographic operations.
[[}]]
[[qa}]]

[[{secret_mng]]
WARN:  [[{101}]]

# KMIP: Key Management Interoperability Protocol PKCS#11[[{101,use_case.secret_mng,protocol.PKCS#11,standards.PKCS,01_PM.TODO]]
* <https://en.wikipedia.org/wiki/Key_Management_Interoperability_Protocol_(KMIP)>

A KMIP server stores and controls Managed Objects such as symmetric
and asymmetric keys, certificates, and user defined objects. Clients
then use the protocol to access these objects subject to a security
model that is implemented by the servers. Operations are provided to
create, locate, retrieve and update managed objects.

Each managed object has an immutable Value such as a key block that
contains a cryptographic key. They also contain mutable Attributes
which can be used to store meta data about the keys. Some attributes
are derived directly from the Value, such as the cryptographic
algorithm and length of a key. Other attributes are defined in the
specification for the management of objects such as the Application
Specific Identifier which is usually derived from tape identification
data. Additional identifiers can be defined by the server or client
as need by the application.

Each object is identified by a unique and immutable object identifier
that is generated by the server and is used to Get object values.
Managed objects may also be given a number of mutable but globally
unique Name attribute which can be used to Locate objects.

The types of managed objects that are managed by KMIP include

- Symmetric Keys.
- Public and Private Keys.
- Certificates and PGP Keys.
- Split Keys.
- Secret Data (passwords).
- Opaque Data for client and server defined extensions.

The operations provided by KMIP include

- Create—to create a new managed object such as a symmetric key,
  and return the identifier.
- Get—to retrieve an object's value given its unique identifier.
- Register—to store an externally generated key value.
- Add Attributes, Get Attributes, and Modify Attributes—to
  manipulate the attributes of a managed object.
- Locate—to retrieve a list of objects based on a conjunction of
  predicates.
- Re-Key—to create a new key that can replace an existing key.
- Create Key Pair—create asymmetric keys.
- (Re-)Certify—to certify a certificate.
- Split and Join n of m keys.
- Encrypt, Decrypt, MAC etc. -- cryptographic operations performed on
  the key management server.
- Export and Import keys to other KMIP servers.
- Operations to implement the NIST key life cycle.
[[}]]



## HashCat: Password Recovery [[{use_case.secret_mng,01_PM.TODO]]
<https://github.com/hashcat/hashcat>
<https://hashcat.net/wiki/>
* world's fastest and most advanced password recovery utility.
* supporting five unique modes of attack for over 200+
  highly-optimized hashing algorithms.
* supports CPUs, GPUs, and other hardware accelerators.
* include facilities to help enable distributed password cracking.
[[}]]

## Password store [[{qa.UX,PM.TODO]]
https://www.passwordstore.org/

Password management should be simple and follow Unix philosophy. With
pass, each password lives inside of a gpg encrypted file whose
filename is the title of the website or resource that requires the
password. These encrypted files may be organized into meaningful
folder hierarchies, copied from computer to computer, and, in
general, manipulated using standard command line file management
utilities.

https://github.com/tadfisher/pass-otp#readme
A pass extension for managing one-time-password (OTP) tokens.
https://github.com/tldr-pages/tldr/blob/master/pages/common/pass.md
Tool for storing and reading passwords or other sensitive data. All
data is GPG-encrypted, and managed with a Git repository. More
information: https://www.passwordstore.org.
[[}]]

[[{secret_mng.wallets]]
## Wallet vs KeyStore vs Vault [[{101,secret_mng.wallet,secret_mng.keystore]]
* In a KeyStore, secrets are kept safe until needed by an application.
  At that moment the secret becomes vulnerable to any virus/warm/attacker on
  the Operating System.
* Keystores are generic for any type of app.
* Vaults are mostly the same that Keystores. In clouds, vaults ussually
  provide access policies (that probably are not available in local
  key-stores).
* In hardware wallets secrets are never exposed outside the wallet.
  Unsigned transactions come in, then signed transactions come out.
  The wallet usually have aditional utility functions like "address agenda",
  "browser of transactions", ...
  Software wallets offer the same functionality as hardware wallets, or
  even more, but are exposed to the underlying security leaks of the OS
  (virus, warms, software leaking secrets, ...)
  * A wallet makes use of a keystore.
  * Wallets are mostly used for blockchain-like applications or digital
    signature applications.
  * HD wallets stand for Hierarchical deterministic wallets, and allow
    to deterministically generate a tree of new secrets from an initial
    "seed" secret. Note that public addresses are mathematically
    determined from the diferent secrets.
  NOTE: Vaults, being a "cloud marketing" biased nomenclature, can
    include wallet-like functionality allowing to sign input and get
    signed output from the vault, with no intervention from the original
    ("unsecure") app. For example Parity considers vaults to be """
    an additional privacy feature on top of wallets to lock away accounts
    behind a second layer of protection encrypting the meta-data
    (public addresses,...) """.

## Hierachical Deterministic (HD) Wallets
* HD wallets (BIP-32, by Pieter Wuille) allow to create N safe private keys
  from a single root "master" key (and its associated N public keys/addresses).
* Also, it is possible to generate the public keys of these
  key-pairs even without access to the private keys, allowing generation
  of new (receive) addresses even when the wallet is encrypted or the
  private keys are stored on a separate device.

  ```
  | SEED > MASTER     CHILD          GRANDCHILD
  |        KEY        KEYS           KEYS
  |        ======     =====          ==========
  |        k_m ┬····> k_m[0]·┬····>  k_m[0][0]
  |            │             ├─···>  k_m[0][1]
  |            │             ├─···>  k_m[0][2]
  |            │             ├─···   ...
  |            │
  |            ├····> k_m[1]·┬····>  k_m[1][0]
  |            │             ├─···>  k_m[1][1]
  |            │             ├─···   ...
  |            │
  |            ├····> k_m[2]·┬····>  k_m[2][0]
  |            ...           ├─···>  ...
  ```
* Use-cases:
  * Preserve anonymity by using many receive addresses.
  * Protect against key-lost      (theorical advantage only?)
  * Allow for easier key rotation (theorical advantage only?)

<https://medium.com/@robbiehanson15/the-math-behind-bip-32-child-key-derivation-7d85f61a6681> by Robbie Hanson

 ```
 | extending parent PRIVATE key to create child PRIVATE key
 |
 | INPUT                                      OUTPUT
 | =====                                      ======
 | k=parent   ·····························>  a=k+h,child[0]
 | priv.key                  h=left    ┌···>  priv.key
 | (256bits)                   256bits ·      (256bits)
 |  ·                                  ·       │
 |  v                                  ·       v
 | K=parent ······> HMAC─SHA512        ·        child[0]
 | pub.key     ┌··> (512bits)    ······┤      pub.key
 | (264bits)   · ┌> one─way func       ·      (264bits)
 | K=G·k       · ·                     ·      A =G·(k+h)
 |             · ·                     ·
 | Parent      · ·                     └···>  child[0]
 | Chain Code ·┘ ·                   rigth   Chain Code
 | (256bits)     ·                   256bits (256bits)
 |               ·
 | Idx Number    ·
 | (32 bits)   ··┘
 | e.g. [0])
 ```

 ```
 | extending parent PUBLIC  key to create child PUBLIC  key
 |
 | INPUT                                      OUTPUT
 | =====                                      ======
 | k = parent ← Not really needed!!!
 | priv.key
 | (256bits)
 |   ·                               left
 |   v                               256bits
 | K=parent                            ┌···>  child[0]
 | pub.key     ┌··> (512bits)    ······┤      pub.key
 | (264bits)   · ┌> one─way func       │      (264bits)
 | (K=G x k)   · ·                     │      A=  K + G·h
 |             · ·                     │       =G·k + G.h
 |             · ·                     │
 | Parent      · ·                     └···>  child[0]
 | Chain Code ·┘ ·                   rigth    Chain Code
 | (256bits)     ·                   256bits  (256bits)
 |               ·
 |               ·
 | Index Number  ·
 | (32 bits)   ··┘
 | e.g. [0]
 ```
* See also. Andrea Corbellini Online tools:
  * ECC mul: <https://andrea.corbellini.name/ecc/interactive/modk-mul.html>
  * ECC add: <https://andrea.corbellini.name/ecc/interactive/modk-add.html>
[[}]]


## Wallet vs Smart-Cards [[{secret_mng,hardware,02_doc_has.comparative]]
* Some types of Smart-Cards can be considered a type of wallet, in
  the sense that they can be used to sign content using a hardware
  protected private-key.
* Still Smart-Cards are mostly designed with Authentication as
  primary use-case, to provide that the user accessing a website,
  a bank terminal, ... is the real authorized user.
* Wallets is mostly a blockchain concept, while smart-card is
  a general device that can be used for many purposes
  (Web TLS or SSH Client Authentication, PGP signature, ...)
* Wallets are designed with TX signature in mind.
  A wallet protects the private key, signs the TXs and probably
  has a display that shows what's going to be signed and a
  physical button that the user must "click" in order to confirm
  the transaction.
* Stealing of the wallet can mean stealing of the money.
* Stealing of the smart-card means money can be stealed until
  the smart-card is cancelled.
[[}]]

## JS Carbon Wallet [[{use_case.signature]]
<https://en.bitcoin.it/wiki/CarbonWallet>

* No server side storage,  private keys are generated from
  the passphrase and only exist in the memory of the browse
* Deterministic key generation: Write down the passphrase
  generated for you and it's all you need
* Transactions are signed locally in the browser: Your
  private keys are not shared with the server. You do not
  have to trust the server with your money
* Privacy: No need to register a passphrase is all that
  is required
* Public code hosted on Github which anyone can audit
[[}]]

## Keepass: OOSS Password Manager [[{]]
* <https://keepass.info/>
* free, open source, light-weight and easy-to-use password manager in a ¿secure? way.
* All passwords are stored in a single database file 
  (encrypted with AES/Twofish)
  locked with one master key (The only pass needed to remember) or a key file.
[[}]]

[[{secret_mng.wallets.hardware]]
## Lattice 1 [[{secret_mng.hardware.lattice1,standards.25519,secret_mng.wallet,use_case.signature]]
* <https://github.com/GridPlus>
* <https://blog.gridplus.io/lattice1-sdk-and-generalized-signatures-e17da7cf65d7>
* Generalized remote (WiFi, Bluetooth?,...) transaction signer.
  Private key is never transmited outside the hardware.
* Update 2020-10-22: First pre-orders available:
  <https://blog.gridplus.io/from-idea-to-reality-the-first-lattice1-hardware-wallets-have-shipped-5e9672e89c32>
### Features
* Better Interface: (when compared to hardware wallets)
                    read exactly what you're signing on a 5" TFT touchscreen. [[qa.UX]]
* More Secure     : Mitigates attack vectors from edge cases that other
                    hardware wallets do not take into account.
* Extensible      : Back up accounts to a PIN-protected SafeCard
* Firmware updates: They will enable support for easy N-of-M hardware multisig using SafeCards.
* Programmable    : Lattice == Linux mini-computer + general and secure compute environments
                    This makes it possible to use permissioned signing for subscriptions
                    or to automate processes such as signing as a proof-of-stake validator.
* Connectivity    : 
  * Pair devices via WiFi.
  * IoT communication through Zigbee antenna.

### TECHNICAL COMPONENTS:
* USER INTERFACE: interface to:
  * persisted user data: addresses, TX history,...
  * network nodes: allow to display account info
* TX BUILDER    :
  convert parameters (amount, recipient address, ...)
  into one or more hashes that make up a TX compatible
  with the Network protocol.
  Note: in Ethereum, each TX is represented by a
    single hash, whereas in Bitcoin each consumed
    input has its own hash to sign,  there can be
    one or many inputs per Bitcoin transaction.
* TX SIGNER     : sign TX hashes with private key.

### SEPARATING THE SIGNER:
1. STEP 1:
  let's consider moving TX signer to cloud machine.
  => you have to store your private key on the cloud
2. STEP 2:
  Move TX builder in the cloud too

"""In Lattice1 we have separated the protocol and
   cryptographic functionality away from the application
   layer ... Of course keys are in a secure chip within
   the Lattice1."""

### SECURING COMPONENTS AND SEPARATING CONCERNS
* robust and secure connection between application
  ("wallet GUI") and TX builder/signer components.

 ```
 | ┌····> "GUI Apps in Cloud"
 | ·
 | v
 |Standard Chip ←·········> Secure Chip 1 <····> Secure Chip 2
 |    ^                        ^                    ^
 |- connect to           - Build TX hashes      - Store priv.keys
 |  outside apps         - Placed on device     - Make signatures
 |- request signatures                          - Placed on device
 |- facilitates (wireless)                        and each Safe Card
 |  communication app←>Sec.Chip
 |  (Lattice1 addition)
 ```

### PRE-SETUP: GUI App Connection :
1. App    generates EC25519 key pair (just once)
1. Chip 1 generates EC25519 key pair (for each new app pairing)
1. PAIRING: ECDH Key exchange is use to interchange
   `App.pub_key <·> Chip1.pub_key_for_app1`

### Pairing App <·> Lattice 1 :
  ""app wants to pair with a user’s Lattice1 device.""

1. STEP 1 ) Find device by serial number
   (not needed if Lattice1 can connect with the app
   on a local area network).
1. STEP 2 ) Pairing: (Similar to pairing Bluetooth)
   - User must enter in Lattice1 the same code shown in App.
1. STEP 3 ): Establish a Read-Only (Minimal) Permission
   Lattice1 gives app permission to view addresses,
   request signatures (that must be authorized on device screen)
   for one-off (vs automated) signatures,...

  After STEP 3, App can be used as a generalized TX Signer like any other
hardware wallet.  Unlike other hardware wallets, however, the paired
application is capable of communicating with the device wirelessly.

### MANUAL REMOTE SIGNING:
* As mentioned above, the pairing process also creates a minimal "permission".
  The application may request a signature using similarly to existing hardware
  wallet TXs:
  * Lattice1 displays TX data to the user and must wait for the user
    to hit "accept" on the touch screen.
  * A few technical differences that are worth noting:
    * data must conform to a pre-defined "schema".
     (periodically released as use cases emerge, like
      ETH transfers and BTC transactions (P2SH|P2PKH).

### AUTOMATIC REMOTE SIGNING (Ex. recurring payments, keep-alive messages)
* Use of "recurring permissions", which require a pre-defined schema
  (just like manual signatures) in addition to a set of "rules" on the
  data that will be signed in the future. Such a permission might look like this:

  ```
  |{
  |  schemaIndex: 0,   <·· published "schema" for Eth TX (0)
  |  typeIndex: 0,     <·· ETh TX type.  0: standard TX (empty data)
  |  rules: [
  |    null    , null         , null,
  |    null    , null         , null,
  |    null    , null         , null,
  |    'equals', '0x397654..' , null,  <·· recipient
  |    'equals', 1000         , null,  <·· wei ammount
  |    'equals', ''           , null,
  |       ^         ^            ^
  |    typeOfRule  value1      value2
  |  ],
  |  timeLimit: 10000                  <·· secs elapsed
  |}                                       between requests
  ```

* specific rules `[ nonce, gas, gasPrice, to, value, data ]`
* Requester can only send a request once every 10_000 seconds.  (~ 2h 40min)

### Grid+ Application SDK:
* OOSS node.js module.
* Example  mobile wallet application also provided as example.
* JS code snippet: (WiP: 2018)
  ```
  | const Sdk = require('gridplus-sdk');
  | const sdk = new Sdk({
  |      btcNode: 'localhost:48332', ethNode: 'localhost:8545' 
  | });
  |
  | const req = {
  |   type: 'eth-transfer',
  |   rules: {
  |     value: { 'equals': 1000 },
  |     to: { 'equals': '0x39765400baa16dbcd1d7b473bac4d55dd5a7cffb' }
  |   },
  |   interval: 10000
  | }
  |
  | sdk.createAutomaticPermission(req, (err, res) => {
  |   ... do stuff ...
  | })
  ```
[[secret_mng.hardware.lattice1}]]

## "Top" hard.Wallets [[{]]
(WARM: Last update 2018, but still relevant as of 2022)
* Ledger Nano
  <https://shop.ledger.com/products/ledger-nano-s>
  * securised key store system:
    * WYSIWYS/BOLOS:
    * Fully-certified by ANSSI, the French cybersecurity agency.
    * Backup:  crypto assets stay safe even if you lose Ledger Nano S.
      A confidential recovery phrase backs up your device,
      and your accounts can easily be restored on any Ledger device.
* KeepKey
  * Controlled through Google Chrome.
  <https://shapeshift.io/keepkey/>
  * Recovery method?
* Safe T-Mini (Archos)
  "Notre avis complet sur le Safe T-mini"
  <https://shop.archos.com/es/hardware-wallet/588-archos-safe-t-mini.html>
  * Recovery method?
* Ledger Blue:
<https://shop.ledger.com/products/ledger-blue>
  * architecture double-chip.
  * To validate TXs, it can comunicate through USB/Bluethooth.
  * Targeting business.
  * "Big" screen for easy ussage.
  *   Recovery method?
* CoolBitX CoolWallet
<https://www.coolwallet.io/>
  * Credit Card format
  * Recovery method?
* Trezor Wallet
  <https://en.bitcoin.it/wiki/TREZOR>
  * BIP 0032 Deterministic hardware wallet.
  * TREZOR is basically a small computer. It is designed to
    protect your private keys from possible online and
    offline risks.
  * Recovery method?
[[}]]
[[secret_mng.wallets.hardware}]]
[[secret_mng.wallets}]]

## Fuzzy Encryption [[{use_case.secret_mng,secret_mng.wallet,qa.UX,01_PM.TODO]]
<https://github.com/decentralized-identity/fuzzy-encryption>

* A variant of a Fuzzy Vault cryptographic scheme, designed for
  encrypting secrets that can be more easily recovered by humans.
[[}]]

## Key Shadowing [[{secret_mng.wallet]]
```
| X: how many of the key shadows are to be generated,
| Y: how many of the key shadows are to be required for decrypting
|    an encrypted message, determining or receiving a master key
|    for decrypting the encrypted message, and determining X key
|    shadows of the master key.
|    >=Y: key-shadows is sufficient to computationally find the master key
|    < Y: computationally infeasible to determine any part of master key.
```
[[}]]

# Hardware Security Module(HSM) (Vaults, encrypt modules,...)

## HSM PROTOCOL/APIs SCHEMA [[{secret_mng,hardware,02_doc_has.diagram]]
```
|        ┃  COMMUNICATION          ┃
|        ┃ APIs/PROTOCOLS          ┃
|        ┃                         ┃
|        ┃ Standard Cross-Platform ┃
|        ┃   - PKCS#10             ┃
|        ┃   -OpenSSL              ┃ HARDWARE
|        ┃   -KMIP                 ┃ SECURITY
|APP     ┃                         ┃  MODULE
|        ┃ Non-Standard and/or     ┃
|        ┃ Non-Cross-Platform      ┃
|        ┃   -Java JCE             ┃
|        ┃   -MS/CAPI              ┃
|        ┃   -"others"             ┃
```

```
 |                         PKCS#11 flow
 |──────────────────────────────────────────────────────────────────────────────────
 |     SOFTWARE                 ┇            HARDWARE
 |______________________________    ┃   ____________________________________________
 |                              ┃       ┌─────────────┐  ┌───┐  ┌──────────────────┐
 |App ←> Driver PKCS#11 ←> OpenSC > ┃ ←>│Crypto OpenSC│←>│Phy│←>│SmartCard ISOXXXX │
 |                              ┃       └─────────────┘  └───┘  └──────────────────┘
```

Ex:
* Securosys HSM, used by R3 Corda to encrypt and sign offline.
  * REF:
  <https://www.securosys.com/en/products/primus-hardware-security-modules-hsm>
  <https://www.youtube.com/watch?v=ydMMb1wcCT0&list=PLi1PppB3-YrVeHKIhNxm3_4NvO0AFSvWr> (~8min:00)
[[}]]

## USB Armory  [[{secret_mng,hardware,secret_mng.keystore,use_case.signature,use_case.AAA,tech_stack.java]]
<https://inversepath.com/usbarmory>
The following example security application ideas
illustrate the flexibility of the USB armory concept:
* Hardware Security Module (HSM)
* encrypted file storage with malware scanning,
  host authentication and data self-destruct
* USB firewall, bridging built-in receptacle and plug ports
* OpenSSH client and agent for untrusted hosts (kiosk)
* router for end-to-end VPN tunnelling, Tor
* password manager with integrated web server
* electronic wallet (e.g. pocket Bitcoin wallet)
* authentication, provisioning or licensing token
* portable penetration testing platform
* low level USB security testing
[[}]]

## Enterprise HSM [[{standards.PKCS,secret_mng,use_case.AAA,hardware,use_case.signature,secret_mng.keystore]]
<https://safenet.gemalto.com/data-encryption/hardware-security-modules-hsms/protectserver-security-module/>

  ```
  |             SECP256K1                      Crytographic APIs
  |           │          ┌────────┬─────────────┬──────────────┬────────┐
  |           │          │ PKCS#11│Java(JCA/JCE)│ MS CAPI  CNG │ OpenSSL│
  |───────────│──────────┼────────┼─────────────┼──────────────┼────────┤
  |nChiper    │          │        │             │              │        │
  |           │          │        │             │              │        │
  |Gemalto    │          │        │             │              │        │
  |(LunaHSM)  │          │        │             │              │        │
  |           │          │        │             │              │        │
  |....
  ```
[[}]]


# Smart Cards [[{]]
## DS/EN 14890-1 Smart-Card Standard [[{]]
* We can see and smartCard as some sort of "slow" / low-power HSM.

Extracted from <https://standards.globalspec.com/std/1167872/DS/EN%2014890-1>
Part 1 of this series specifies the application interface to Smart Cards
during the usage phase, used as Secure Signature Creation Devices (SSCD)
describing the mandatory services ... covering the signing function , 
storage of certificates, related user verification, establishment and 
use of trusted path and channel, requirements for key generation...  
the functionality of CWA 14890-1 is enhanced in the following areas:
* Device authentication with Elliptic Curves (ELC)
  for existing asymmetric authentication protocols
  (RSA Transport, Privacy Protocol)
* Secure Messaging Tags
* Further hash algorithms (SHA2-family)
* Use of AES in auth protocols and secure messaging.  [[}]]
## GNUPGP SC [[{secret_mng,standards.pgp,tool.gpg,standards.smartcard,hardware.smartcard]]
*<https://www.commoncriteriaportal.org/cc/>
   Supporting Documents related to Smart Cards and similar devices
   ```
   | Document number     Document title  Class
   | 2006-06-001         Rationale for Smart cards and similar devices
   | CCDB-2010-03-001    Guidance for smartcard evaluation v2.0  Guidance
   | CCDB-2014-04-001    Security Architecture requirements (ADV_ARC) for
   |                     smart cards and similar devices (Mandatory)
   | CCDB-2009-03-002    Application of CC to Integrated Circuits v3.0  (Mandatory)
   | CCDB-2012-04-001    Composite product evaluation for Smartcards    (Mandatory)
   |                     and similar devices
   | CCDB-2007-09-02     ETR-template lite for composition Guidance
   | CCDB-2012-04-004    Security Architecture requirements (ADV_ARC)   (Guidance)
   |                     for smart cards and similar devices - Appendix 1
   | CCDB-2013-05-001    Minimum ITSEF Requirements for Security  (Mandatory)
   |                     Evaluations of Smart cards and similar devices
   | CCDB-2013-05-002    Application of Attack Potential to Smartcards  (Mandatory)
   ```

- GNUPGP Smart Card specs
* <https://gnupg.org/ftp/specs/>
* <http://cardwerk.com/iso-7816-smart-card-standard/>         [standards.hardware]

* Extracted from <https://en.wikipedia.org/wiki/Smart_card>
  """PGP SmartCard is the most widely used Crypto Commands include:
  * PSO: COMPUTE DIGITAL SIGNATURE
  * HASH ALGORITHMS
  * DigestInfo for RSA
  * PSO: DECIPHER
  * PSO: ENCIPHER
  * INTERNAL AUTHENTICATE
    + Client/Server Authentication
  * GENERATE ASYMMETRIC KEY PAIR
  * GET CHALLENGE
  * TERMINATE DF
  """
[[}]]

### Related: GPG SmartCard for SSH Authentication
* <https://www.grepular.com/Smart_Cards_and_SSH_Authentication> [TODO]
  ```
  | SSH KEY SETUP
  |────────────────────┬──────────────────────────────────────
  |STANDARD(SOFTWARE)  │ PGP (HARDWARE)
  |SSH KEYGEN          │ SMART-CARD:
  |────────────────────┼──────────────────────────────────────
  |          GENERATING THE KEYS
  |────────────────────┼──────────────────────────────────────
  |$ ssh-keygen ...    │ (Install GnuPG 2 first)
  |                    │   $ gpg -gen-key  # Generate a keypair:
  |                    │   $ gpg -edit-key # ← Add  authentication subkey
  |                    │   > addkey        # ←
  |                    │   > keytocard     # ← transfer private part of
  |                    │                   #   subkey to smart-card
  |                    │                   #   A stub referencing subkey 
  |                    │                   #   is left behind
  |                    │                   #   with your on disk keypair.
  |                    │
  |                    │ - Whenever you try to use that subkey, the system
  |                    │   will request that you insert the smart card.
  |                    │
  |────────────────────┼──────────────────────────────────────
  |          ADDING AUTH.SUBKEY TO SSH LIST OF AUTHORIZED KEYS
  |────────────────────┼──────────────────────────────────────
  |$ ssh-copy-id ...   │  ("gpgkey2ssh" utility is provided 
  |                    │  by the gnupg-agent package )
  |                    │  Alt 1:
  |                    │    $ gpgkey2ssh $gpgSubkeyID_for_sshAuth \
  |                    │      > output_ssh_formated_pubkey
  |                    │        ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                    │    C+P to remote "~/ssh/authorized_keys" file
  |                    │
  |                    │  Alt 2: (If the auth.subkey is on 
  |                    │          public gpg keyservers):
  |                    │    $ gpg --recv-key 0018461F
  |                    │    $ gpgkey2ssh 13990B29 >> ~/.ssh/authorized_keys
  |────────────────────┴──────────────────────────────────────
  ```

* AUTHENTICATING USING THE SMART CARD
  (how do we get the OpenSSH client to use the smart card)
  ```
  |────────────────────┬──────────────────────────────────────
  |STANDARD(SOFTWARE)  │ PGP (HARDWARE)
  |SSH KEYGEN          │ SMART-CARD:
  |────────────────────┼──────────────────────────────────────
  |(setup ssh-agent)   │ gpg-agent has been designed to speak
  |                    │ the same protocol as ssh-agent
  |                    │
  |                    │ - STEP 01:
  |                    │   stop ssh-agent process
  |                    │ - STEP 02:
  |                    │   add "enable-ssh-support" to
  |                    │   ~/.gnupg/gpg-agent.conf
  |                    │
  |                    │ ( OpenSSH client should start talking
  |                    │   to gpg-agent now )
  |                    │
  |                    │ - STEP 03:
  |                    │   $ ssh-add -l
  |                    │ ( You should see that the key you
  |                    │   generated previously is mentioned
  |                    │   only when the S.C. is inserted!!! )
  |                    │
  |                    │ you’re done!!
  |                    │ ssh'ing to a remote machine with your pubkey
  |                    │ will ask to type your pin on the smart-card
  |                    │ reader.
  ```
  (See original ref for Windows/Putty setup)

* List of Implementations of the OpenPGP application for smart cards
  <https://incenp.org/notes/2016/openpgp-card-implementations.html>
* <https://g10code.com/>
  """Founded by the principal author of GnuPG ...
     we provide custom development, enhancements
     and audits of cryptographic software.
     An ongoing effort of ours is the development
     and maintenance of GnuPG and related software."""
  * OpenPGP (Smart)Card Specs:
  <https://g10code.com/p-card.html>
  * <https://openpgpcard.net/>
    WARN: Does not include display
  * Hardware cryptocurrency wallet
  * OpenPGP smart card
  * U2F authenticator
  * One-time password generator
[[}]]

## CardPeek [[{standards.smartcard,hardware.smartcard,01_PM.TODO]]
* <http://pannetrat.com/Cardpeek>
* Linux/Windows/Mac OS X tool to read the contents
  of ISO7816 smart cards. It features a GTK GUI to
  represent card data is a tree view, and is extensible
  with a scripting language (LUA).
* The goal of this project is to allow smart card owners to
  be better informed about what type of personal information
  is stored in these devices.
* As of version 0.8.2, this tool is capable of reading the contents
  of the following types of cards:
* EMV "chip and PIN" bank cards, including:
  VISA, MasterCard, CB and UK Post Office Account contact cards;
  PayWave (VISA) and PayPass (MasterCard) contactless cards;
* Electronic/Biometric passports, which have an embedded contactless chip;
* The Belgian eID card;
* Calypso transport cards including:
  * Navigo transport cards used in Paris;
  * MOBIB cards used in Brussels;
  * RavKav cards used in Israel;
  * VIVA cards used in Lisbon;
* GSM SIM cards (without USIM data used in recent cards);
* Vitale 2, the French health card.
* Moneo, the French electronic purse;
* Driver Tachograph cards;
* OpenPGP Cards (beta);

Some important card types are missing or need further development,
however, this application can be modified and extended easily to your
needs with the embedded LUA scripting language
[[}]]

## OpenCryptoJC.org [[{02_doc_has.comparative]]
* <http://opencryptojc.org/>
  (Speed Up JavaCard Dev)
* [Video] Unchaining the JavaCard Ecosystem (2018-02-22)
  <https://www.youtube.com/watch?v=vd0-Uhx2OoQ>
* Project providing convinient libraries for JavaCard development
  including Integers, Big Numbers, Elliptic Curves and Profilers.
* Java Card Comparision
  <https://www.fi.muni.cz/~xsvenda/jcalgtest/index.html>
[[}]]

## OpenSCDP: Dev tools for S.C. [[{IoT.smart_cards,standards,]]
* https://www.openscdp.org/
* Why use more than one scripting environment for all your smart card
  simulation, testing, data preparation, personalization and key
  management needs ?" - Andreas Schwier, OpenSCDP founder
* The Open Smart Card Development Platform (OpenSCDP) is a collection
  of tools for the development, test and deployment of smart card and
  public key infrastructure applications. It uses the capabilities of
  Global Platform Scripting, Profile and Messaging technology to
  provide unsurpassed flexibility and development speed.
[[IoT.smart_cards}]]
[[}]]

@ma
# Trusted Execution Environment [[{]]
* REFS: 
  <https://en.wikipedia.org/wiki/Trusted_execution_environment>
  <https://en.wikipedia.org/wiki/Trusted_Platform_Module>

Summary from:
<https://www.infoq.com/presentations/iot-cloud-options-production/>
* different providers, platforms and structures.
* 10-second pitch: "you can do something with secrets in
  a trusted environment where nobody else has access or
  visibility into what's going on
  It's ability to encrypt, decrypt, sign, provide attestation.
  A general purpose environment that is structured separately
  from the rest of the runtime.
  It changes the model for security. ...
  really anything that requires some sensitive computing
  really should be considered in the realm of TXE.
* hardware enclaves are a subset of TXE.
* Before TXE:
  "You had some process running on some machine that would
   contact a HSM and perform an operation sign/verify/encrypt/...
   It would typically happen over a PKCS 11 channel or
   HTTP REST APIs.
   If you wanted something encrypted, you would send it to
   HSM and it would come back encrypted.
   PRETTY SIMPLE IDEA, VERY COMPLICATED SETUP, VERY COSTLY TO USE.
   ULTIMATELY, REDUNDANCY AND RESILIENCY WERE DIFFICULT PROBLEMS
   TO SOLVE."
* After TXE:
  "TXE changes the model a little bit. Now I'm going to live
  inside of the execution runtime of the application,
  inside or close to the processor.
  Data edge shipped in and out of the process runtime, and
  special instruction sets or special machine code can be
  run to perform the enclave or a T.Env.Exec.
  you're in a world where there's not maybe a reliable network,
  or the ability to communicate with an HSM.
  Intel has Software Guard Extensions SGX. .. full end-to-end
  example of how to seal and unseal a secret inside of SGX
  AMD has a similar platform Secure Execution Environment: SEV.
  with a few notable differences.
  ARM has TrustZone available on a majority of the ARM platform
  system on a chip environments.
  Apple has Secure Enclave: (It has been around for quite a while).
  AWS has Nitro Enclaves.
  Google Cloud and Microsoft Azure have similar enclave offerings,
  but they tend to rely on AMD SEV or Intel SGX.
* KEY-POINT: hardware enclaves represent a change in the threat model.
  (what can go wrong).  while side channels are a lot more difficult 
  to pull off, they still exist.
* you have a bunch of untrusted code ... when you need to operate on
  a secret, you enter a trusted code.
* You'll ship the code or you'll ship the data you want to en/de-crypt
  into the enclave, let it perform its duties, and it will return the
  results.
* different vendors offer different "ergonomics" (simplicity/SDKs)
  * Apple wins head on: The ease of use in Apple's Secure Enclave environment
    is awesome. Great documentation, available in Swift and Objective-C.
    Build very easily to Xcode. It feels "batteries included".
  * ARM TrustZone looks to be the one going further into the market of mobile, IoT,...
  * Intel offers the more comple approach....unfortunately it is one of the more
    difficult ones to get going and use.
* Some designs rely on protection rings versus true separation:
  you're at a kernel level at ring 0 dropping to ring -3 to do the enclave transaction.
  (Intel SGX style).
* Some designs have even separate chips. (vs separate instruction set)
* Some implementations requires registering a set of keys with the vendor, authorizing
  your keys to run inside of an environment. There's not just a plug and play deploy
* Availability:
  * ARM:  there are unssuported chips.
  * Apple: supports it for a broad majority.
  * Intel: SGX available in pizza boxes, smaller servers but more capable enterprise grade
         servers don't come with any support for SGX. (roadmap to include in next generations)
* SGX gives the simulation mode """As long as you have the SDK and the SDK can be compiled and installed,
  you can compile and run SGX based applications in simulation mode, which is great
  if I understand it correctly, still just using OpenSSL under the hood. You're getting all of the same
  types of operations you'd get. OpenSSL is inside of the enclave as well.  """
* """ If you have a fleet of thousands of machines in a fully networked environment,
   I think the scale problem, HSMs are going to solve that in a more meaningful way.
   ... If you're designing an IoT system ...  it's a whole different conversation"""<br/>
   <br/>
   """ we're putting a lot of faith in vendors much like we put a lot
     of faith in the hardware security module vendors...  There used to be
     a lot of them and they keep buying each other ... the vendor trust is
     actually shrinking in the HSM space """
   <br/>
  """ attackers have 100% of their time to attack and you have some very
   small fraction of your time to defend unless your entire business is
   security and protection """
* In the world of ASICs and FPGAs, you only get what you design.
* The most critical thing here is, in your application, preventing the side channel.
  As you're marshaling data, making sure that you're not leaking the key material.
  The key material goes into the enclave sealed. It stays sealed. You're never
  exporting key material out. The idea of the OCALL versus ECALL. The sensitive data
  needs to always happen in the ECALL. Then what's shipped out in the OCALL boundary
  needs to be vanilla plain, not secret.
[[}]]

## [Intel SGX](https://en.wikipedia.org/wiki/Software_Guard_Extensions)

REF: <https://software.intel.com/en-us/blogs/2013/09/26/protecting-application-secrets-with-intel-sgx>

  WARN: SGX was vulnerable to Meltdown and Spectre hardware bugs
CPU instruction set allowing user-level code to allocate
private regions of memory (enclaves) protected from
processes running at higher privilege levels. (secure
remote computation, secure web browsing, DRM).

SGX is a set of instruction set extensions for CPUs
released in Fall 2015 and available on recent CPUs. The
key ability SGX provides is the notion of confidential,
private execution with integrity guarantees. In essence,
the chip has a special construct called an enclave. An
enclave is like an ordinary program, except that the
memory contents of an enclave are encrypted whenever they
are off-chip, and accessible only on-chip, and only while
the special enclave code is running. Further, the
decryption keys are available solely to code with a
certain hash: if you or a hacker were to hack the enclave
code and change its hash, that hacked code will no longer
have access to the encryption keys, repelling attacks. As
a result, this ingenious technology does not permit anyone
, even the owner of the machine who can modify the code
arbitrarily, to peek at the contents of the enclave or to
modify execution within an enclave. Further, the SGX
hardware enables remote attestation, that is, the ability
to prove to a remote computer that a given enclave is
running a particular software distribution. In essence,
the chip is able to issue a statement that says "I
guarantee to any remote party that I am running this code
with this particular hash," which is a critical
bootstrapping mechanism. Teechan is built on these two
underlying features, which, together, provide a trusted
execution environment (TEE).
[[}]]

## TresorSGX [[{secret_mng.wallet,secret_mng.hardware,01_PM.TODO]]
* attempt to isolate+secure an OS component of the Linux kernel.
  - It outsources a functionality of a kernel module into a SGX
  container / enclave. TresorSGX provides a cryptographic algorithm for
  the Linux Crypto API which is executed in the secured container. The
  cryptographic key material is guarded from unauthorised access of
  unprivileged and privileged components at any time. This protects the
  disk-encryption system from cold-boot and DMA attacks on the key
  material.  [[}]]
[[}]]



# Vault services & KMS [[{01_PM.TODO]]
## HashiCorp Vault Project
  https://www.vaultproject.io/
"""HashiCorp Vault secures, stores, and tightly controls
  access to tokens, passwords, certificates, API keys, and
  other secrets in modern computing. Vault handles leasing,
  key revocation, key rolling, and auditing. Through a
  unified API, users can access an encrypted Key/Value
  store and network encryption-as-a-service, or generate
  AWS IAM/STS credentials, SQL/NoSQL databases, X.509
  certificates, SSH credentials, and more. "

* https://github.com/hashicorp/vault">Vault@Github

## Keywhiz
<https://square.github.io/keywhiz/>

## Crypt
<https://xordataexchange.github.io/crypt/>
(in combination with with etcd or consul)

## Key Management Services
- Azure Key Vault   : Allows for "many-keys"  per Vault resource with a
                      very low cost.
- Amazon KMS        : very simple, single key per KMS. An (very) expensive
                      CloudHSM is needed for the "many keys" use-case.
- Google Cloud KMS  :
- Android Keystore  :
- Apple iOS KeyChain:
- ...
[[}]]

## Gemalto: Data protection AaS [[{secret_mng.hardware}]]
<https://safenet.gemalto.com/resources/data-protection/data-protection-as-a-service-suite-solution-brief/>


# TODO/Non-Classified

## Ciphey/Ciphey [[{qa.UX,hacking]]
* Automatically decrypt encryptions without
  knowing the key or cipher, decode encodings,
  and crack hashes
* https://github.com/Ciphey/Ciphey

  ```
  | $ ciphey -vvv -t 360w0x11450x114504421611100x0y0545000x06171y1511070145150x110z45081709110y45071y1100423w2z3045120z0x060z450x1145080w170042060z0u1509071w45160w040x45160y0y020v0045001x1107453w2w374y422x0y1111000301450w03450w0y091y4510110x0y05450442160x0x02090745071y110042030z104504420v001y45120z0x060z450x11450003161x42110z42071717110042030z10060042041642110w071700420x16420z0y0v1x4550505342150z11160x000x090y11001149450u1009160x45001x1107450v071x1642060z170901420w04140045160w0z170416030y0111450z0445150w16160y070x0v0x110716450u040v0y0y02420x11420w04100145160z450017101600030w1706074y453z2z37160z0z0v450x1145041500160w08004207000104101100450y114501040y42061703060v42070z160w45110x0y05090042071x160045030y014208100v110x42071x1600453z2z3742000y01171x121100064511071w114x452z0x060042260x120w001y450w0316453z2z37160z0z0v450x0x1100051704160001420x0y160z450y1149420x1142120x0v0945000045111015071745030804180x0y0545040x0145150x090v451012021703010042260x120w001y45110w450707450400090042110z42061703060v42060z0u1509071w453z2z3742000y01171x121100064511071w114x45320z1x450y1645160w0x114511071w1142160z42090z0x025z4227000104101100453z2z37160z0z0v45060w1009060y4216450610040609450x1645120z000y422x450u040107450x1645160z0z171600174x455u4z
  | 
  | I think the plaintext is a Discover Card Number
  |   Possible plaintext: '360w0x11450x114504421611100x0y0545000x06171y1511070145150x1
  |   10z45081709110y45071y1100423w2z3045120z0x060z450x1145080w170042060z0u1509071w451
  |   60w040x45160y0y020v0045001x1107453w2w374y422x0y1111000301450w03450w0y091y4510110
  |   x0y05450442...'
  ```

[[}]]


## Coinbase Kryptology [[{PM.TODO]]
* library of distributed crypto algorithms
 https://www.itsfoss.net/coinbase-publishes-kryptology-library-of-distributed-crypto-algorithms/amp/ 
[[}]]

## Noble ed25519: Fastest JS implementation [[{]]
* <https://github.com/paulmillr/noble-ed25519>
* Fastest JS implementation of ed25519, an elliptic curve that could be
  used for EDDSA signature scheme and X25519 ECDH key agreement.
  Conforms to RFC7748, RFC8032 and ZIP215. Includes support for
  ristretto255: a technique for constructing prime order elliptic curve
  groups with non-malleable encodings.
* Audited by an independent security firm: no vulnerabilities have been
  found. online demo.
[[}]]

## Homomorphic Encryption [[{crypt.zero_knowledge,use_case.privacy,PM.RADAR]]
* <https://en.wikipedia.org/wiki/Homomorphic_encryption>
* <http://enigma.media.mit.edu/>
* Fully homomorphic Encrypt.:
  <https://www.infoq.com/news/2020/06/ibm-fully-homomorphic-encryption/>
* WARN: young field which attracts with lot of research.
* Broadly classifiable within secure multi-party computation,
  Homomorphic Encryption is an approach to secure
  computation that does not require decrypting your data in order to
  process them. It enables processing ciphertexts with the guarantee
  that encrypted results match those that would be produced by
  first decrypting input data, processing them, and re-encrypting.
* List of SDKs:
  * IBM Fully Homomorphic Encryption Toolkit, based on open source HELi.
    providing a number of low-level routines such set, add, multiply, shift,
    ... along with higher-level features for automatic noise management,
    multi-threading, and so on.  <https://github.com/homenc/HElib>
  * Microsoft SEAL (Simple Encrypted Arithmetic Library)
    <https://www.microsoft.com/en-us/research/project/microsoft-seal/>
  * Google "Private Join and Compute" tool:
    <https://github.com/google/private-join-and-compute>
[[}]]

## OKKA ASA: SSH + PKI [[{protocol.ssh,qa.automatization,use_case.secret_mng,use_case.identity]]
* <https://dzone.com/articles/ssh-is-dead-long-live-ssh-one-million-ssh-logins-w>
*  ...more of our customers have come to the realization that server
   access is an identity problem first and foremost....
   The more you can unify access with identity, the better.
* "...Our customers use Okta Advanced Server Access  (Okta ASA) to
  securely automate identity and access controls for their teams to use
  SSH safely. And we've just reached a significant adoption milestone
  by registering over 1 million SSH logins per month... and growing!..."
  With Okta ASA, SSH logins now follow a familiar Single Sign-On experience,
* SSH transport protocol is inherently secure but the backing    [secret_mng]
  credential mechanism is prone to human error. Companies are forced to:
  * Implement a security policy forcing users to rotate their 
    personal SSH Keys (easiest, least secure).
  * Operate a secure vault service storing SSH Keys checked out on 
    demand (harder, more secure).
  * Purchase and deploy a privileged access management product to act 
    as a gateway for remote access (hardest, most secure).
* OpenSSH introduced in 2011 the capability to authenticate using a
  Client Certificate (vs SSH Key). Client Certs metadata carry
  cryptographically verifiable metadata to store usernames, roles, ...
  and an  expiration date .
[[}]]
