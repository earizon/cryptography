[[{secret_mng]]
# Secret Management Solutions (vs cryptographic primitives)

[[{101,use_case.secret_mng,protocol.PKCS#11,standards.PKCS,PM.TODO]]
# KMIP: Key Management Interoperability Protocol PKCS#11
* <https://en.wikipedia.org/wiki/Key_Management_Interoperability_Protocol_(KMIP)>

* A KMIP server creates/update/retrieve managed objects such as
  (a)symmetric keys, certificates and user defined objects.
* Clients access the objects  through the PKCS#11 protocol.

* Each managed object has:
  1. unique immutable object identifier generated by the server.
  1.  0+ mutable but globally unique Name attribute  (aliases?)
  1. an immutable Value such as a key block (with a cryptographic key,...)
  1. 0+ mutable Attributes for key metadata.
     * Some attributes are derived from the Value value 
       (cryptographic algorithm, key length,...).
     * Others are defined in the specification for the management of objects
       * Application Specific Identifier.
       * Client and/or server metadata.
       * ...
* Object types include:
  - Symmetric Keys.
  - Public and Private Keys.
  - Certificates and PGP Keys.
  - Split Keys.
  - Secret Data (passwords).
  - Opaque Data for client and server defined extensions.

* Operations provided include:
  - Create: returning a new identifier.
  - Get: using the unique identifier.
  - Register: store externally generated key value.
  - Add/Get/Modify Attributes.
  - Locate: retrieve a list of objects based on predicates.
  - Re-Key: create new key that can replace an existing key.
  - Create Key Pair: create asymmetric keys.
  - (Re-)Certify: Certify a certificate.
  - Split and Join n of m keys.
  - Encrypt, Decrypt, MAC etc.: crypto.operations performed on
    the key management server.
  - Export and Import keys to other KMIP servers.
  - Operations to implement the NIST key life cycle. [[{101}]]
[[}]]

## HashCat: Password Recovery [[{use_case.secret_mng,PM.TODO]]
<https://github.com/hashcat/hashcat>
<https://hashcat.net/wiki/>
* world's fastest and most advanced password recovery utility.
* supporting five unique modes of attack for over 200+
  highly-optimized hashing algorithms.
* supports CPUs, GPUs, and other hardware accelerators.
* include facilities to help enable distributed password cracking.
[[}]]

## Password store [[{,secret_mng.passwordstore,qa.UX,PM.TODO]]

* <https://www.passwordstore.org/>

* Password management should be simple and follow Unix philosophy
  ... each password lives inside of a gpg encrypted file whose
  filename is the title of the website or resource that requires the
  password. 
* (encrypted) files can be organized into meaningful folder
  hierarchies, copied from computer to computer, manipulated
  with standar utilities.
* It can be managed in Git repos.

* <https://github.com/tadfisher/pass-otp#readme>
  password extension for one-time-password (OTP) tokens.
  * <https://github.com/tldr-pages/tldr/blob/master/pages/common/pass.md>
[[}]]

## Wallet vs KeyStore vs Vault [[{101,secret_mng.wallets,secret_mng.keystore]]
* In a KeyStore, secrets are kept safe until needed by an application.
  At that moment the secret becomes vulnerable to any virus/warm/attacker on
  the Operating System.
* Keystores are generic for any type of app.
* Vaults are mostly the same that Keystores. In clouds, vaults ussually
  provide access policies (that probably are not available in local
  key-stores).
* In hardware wallets secrets are never exposed outside the wallet.
  Unsigned transactions come in, then signed transactions come out.
  The wallet usually have aditional utility functions like "address agenda",
  "browser of transactions", ...
  Software wallets offer the same functionality as hardware wallets, or
  even more, but are exposed to the underlying security leaks of the OS
  (virus, warms, software leaking secrets, ...)
  * A wallet makes use of a keystore.
  * Wallets are mostly used for blockchain-like applications or digital
    signature applications.
  * HD wallets stand for Hierarchical deterministic wallets, and allow
    to deterministically generate a tree of new secrets from an initial
    "seed" secret. Note that public addresses are mathematically
    determined from the diferent secrets.
  NOTE: Vaults, being a "cloud marketing" biased nomenclature, can
    include wallet-like functionality allowing to sign input and get
    signed output from the vault, with no intervention from the original
    ("unsecure") app. For example Parity considers vaults to be """
    an additional privacy feature on top of wallets to lock away accounts
    behind a second layer of protection encrypting the meta-data
    (public addresses,...) """.

## Hierachical Deterministic (HD) Wallets
* HD wallets (BIP-32, by Pieter Wuille) allow to create N safe private keys
  from a single root "master" key (and its associated N public keys/addresses).
* Also, it is possible to generate the public keys of these
  key-pairs even without access to the private keys, allowing generation
  of new (receive) addresses even when the wallet is encrypted or the
  private keys are stored on a separate device.

  ```
  | SEED > MASTER     CHILD          GRANDCHILD
  |        KEY        KEYS           KEYS
  |        ======     =====          ==========
  |        k_m ┬····> k_m[0]·┬····>  k_m[0][0]
  |            │             ├─···>  k_m[0][1]
  |            │             ├─···>  k_m[0][2]
  |            │             ├─···   ...
  |            │
  |            ├····> k_m[1]·┬····>  k_m[1][0]
  |            │             ├─···>  k_m[1][1]
  |            │             ├─···   ...
  |            │
  |            ├····> k_m[2]·┬····>  k_m[2][0]
  |            ...           ├─···>  ...
  ```
* Use-cases:
  * Preserve anonymity by using many receive addresses.
  * Protect against key-lost      (theorical advantage only?)
  * Allow for easier key rotation (theorical advantage only?)

<https://medium.com/@robbiehanson15/the-math-behind-bip-32-child-key-derivation-7d85f61a6681> by Robbie Hanson

 ```
 | extending parent PRIVATE key to create child PRIVATE key
 |
 | INPUT                                      OUTPUT
 | =====                                      ======
 | k=parent   ·····························>  a=k+h,child[0]
 | priv.key                  h=left    ┌···>  priv.key
 | (256bits)                   256bits ·      (256bits)
 |  ·                                  ·       │
 |  v                                  ·       v
 | K=parent ······> HMAC─SHA512        ·        child[0]
 | pub.key     ┌··> (512bits)    ······┤      pub.key
 | (264bits)   · ┌> one─way func       ·      (264bits)
 | K=G·k       · ·                     ·      A =G·(k+h)
 |             · ·                     ·
 | Parent      · ·                     └···>  child[0]
 | Chain Code ·┘ ·                   rigth   Chain Code
 | (256bits)     ·                   256bits (256bits)
 |               ·
 | Idx Number    ·
 | (32 bits)   ··┘
 | e.g. [0])
 ```

 ```
 | extending parent PUBLIC  key to create child PUBLIC  key
 |
 | INPUT                                      OUTPUT
 | =====                                      ======
 | k = parent ← Not really needed!!!
 | priv.key
 | (256bits)
 |   ·                               left
 |   v                               256bits
 | K=parent                            ┌···>  child[0]
 | pub.key     ┌··> (512bits)    ······┤      pub.key
 | (264bits)   · ┌> one─way func       │      (264bits)
 | (K=G x k)   · ·                     │      A=  K + G·h
 |             · ·                     │       =G·k + G.h
 |             · ·                     │
 | Parent      · ·                     └···>  child[0]
 | Chain Code ·┘ ·                   rigth    Chain Code
 | (256bits)     ·                   256bits  (256bits)
 |               ·
 |               ·
 | Index Number  ·
 | (32 bits)   ··┘
 | e.g. [0]
 ```
* See also. Andrea Corbellini Online tools:
  * ECC mul: <https://andrea.corbellini.name/ecc/interactive/modk-mul.html>
  * ECC add: <https://andrea.corbellini.name/ecc/interactive/modk-add.html>
[[}]]


## Wallet vs Smart-Cards [[{secret_mng,hardware,doc_has.comparative]]
* Some types of Smart-Cards can be considered a type of wallet, in
  the sense that they can be used to sign content using a hardware
  protected private-key.
* Still Smart-Cards are mostly designed with Authentication as
  primary use-case, to provide that the user accessing a website,
  a bank terminal, ... is the real authorized user.
* Wallets is mostly a blockchain concept, while smart-card is
  a general device that can be used for many purposes
  (Web TLS or SSH Client Authentication, PGP signature, ...)
* Wallets are designed with TX signature in mind.
  A wallet protects the private key, signs the TXs and probably
  has a display that shows what's going to be signed and a
  physical button that the user must "click" in order to confirm
  the transaction.
* Stealing of the wallet can mean stealing of the money.
* Stealing of the smart-card means money can be stealed until
  the smart-card is cancelled.
[[}]]

## JS Carbon Wallet [[{use_case.signature]]
<https://en.bitcoin.it/wiki/CarbonWallet>

* No server side storage,  private keys are generated from
  the passphrase and only exist in the memory of the browse
* Deterministic key generation: Write down the passphrase
  generated for you and it's all you need
* Transactions are signed locally in the browser: Your
  private keys are not shared with the server. You do not
  have to trust the server with your money
* Privacy: No need to register a passphrase is all that
  is required
* Public code hosted on Github which anyone can audit
[[}]]

## Keepass: OOSS Password Manager [[{]]
* <https://keepass.info/>
* free, open source, light-weight and easy-to-use password manager in a ¿secure? way.
* All passwords are stored in a single database file 
  (encrypted with AES/Twofish)
  locked with one master key (The only pass needed to remember) or a key file.
[[}]]

[[{secret_mng.hardware.lattice1,standards.25519,secret_mng.wallets,use_case.signature]]
## Lattice 1 
* <https://github.com/GridPlus>
* <https://blog.gridplus.io/lattice1-sdk-and-generalized-signatures-e17da7cf65d7>
* Generalized remote (WiFi, Bluetooth?,...) transaction signer.
  Private key is never transmited outside the hardware.
* Update 2020-10-22: First pre-orders available:
  <https://blog.gridplus.io/from-idea-to-reality-the-first-lattice1-hardware-wallets-have-shipped-5e9672e89c32>
### Features
* Better Interface: (when compared to hardware wallets)
                    read exactly what you're signing on a 5" TFT touchscreen. [[qa.UX]]
* More Secure     : Mitigates attack vectors from edge cases that other
                    hardware wallets do not take into account.
* Extensible      : Back up accounts to a PIN-protected SafeCard
* Firmware updates: They will enable support for easy N-of-M hardware multisig using SafeCards.
* Programmable    : Lattice == Linux mini-computer + general and secure compute environments
                    This makes it possible to use permissioned signing for subscriptions
                    or to automate processes such as signing as a proof-of-stake validator.
* Connectivity    : 
  * Pair devices via WiFi.
  * IoT communication through Zigbee antenna.

### TECHNICAL COMPONENTS:
* USER INTERFACE: interface to:
  * persisted user data: addresses, TX history,...
  * network nodes: allow to display account info
* TX BUILDER    :
  convert parameters (amount, recipient address, ...)
  into one or more hashes that make up a TX compatible
  with the Network protocol.
  Note: in Ethereum, each TX is represented by a
    single hash, whereas in Bitcoin each consumed
    input has its own hash to sign,  there can be
    one or many inputs per Bitcoin transaction.
* TX SIGNER     : sign TX hashes with private key.

### SEPARATING THE SIGNER:
1. STEP 1:
  let's consider moving TX signer to cloud machine.
  => you have to store your private key on the cloud
2. STEP 2:
  Move TX builder in the cloud too

"""In Lattice1 we have separated the protocol and
   cryptographic functionality away from the application
   layer ... Of course keys are in a secure chip within
   the Lattice1."""

### SECURING COMPONENTS AND SEPARATING CONCERNS
* robust and secure connection between application
  ("wallet GUI") and TX builder/signer components.

 ```
 | ┌····> "GUI Apps in Cloud"
 | ·
 | v
 |Standard Chip ←·········> Secure Chip 1 <····> Secure Chip 2
 |    ^                        ^                    ^
 |- connect to           - Build TX hashes      - Store priv.keys
 |  outside apps         - Placed on device     - Make signatures
 |- request signatures                          - Placed on device
 |- facilitates (wireless)                        and each Safe Card
 |  communication app←>Sec.Chip
 |  (Lattice1 addition)
 ```

### PRE-SETUP: GUI App Connection :
1. App    generates EC25519 key pair (just once)
1. Chip 1 generates EC25519 key pair (for each new app pairing)
1. PAIRING: ECDH Key exchange is use to interchange
   `App.pub_key <·> Chip1.pub_key_for_app1`

### Pairing App <·> Lattice 1 :
  ""app wants to pair with a user’s Lattice1 device.""

1. STEP 1 ) Find device by serial number
   (not needed if Lattice1 can connect with the app
   on a local area network).
1. STEP 2 ) Pairing: (Similar to pairing Bluetooth)
   - User must enter in Lattice1 the same code shown in App.
1. STEP 3 ): Establish a Read-Only (Minimal) Permission
   Lattice1 gives app permission to view addresses,
   request signatures (that must be authorized on device screen)
   for one-off (vs automated) signatures,...

  After STEP 3, App can be used as a generalized TX Signer like any other
hardware wallet.  Unlike other hardware wallets, however, the paired
application is capable of communicating with the device wirelessly.

### MANUAL REMOTE SIGNING:
* As mentioned above, the pairing process also creates a minimal "permission".
  The application may request a signature using similarly to existing hardware
  wallet TXs:
  * Lattice1 displays TX data to the user and must wait for the user
    to hit "accept" on the touch screen.
  * A few technical differences that are worth noting:
    * data must conform to a pre-defined "schema".
     (periodically released as use cases emerge, like
      ETH transfers and BTC transactions (P2SH|P2PKH).

### AUTOMATIC REMOTE SIGNING (Ex. recurring payments, keep-alive messages)
* Use of "recurring permissions", which require a pre-defined schema
  (just like manual signatures) in addition to a set of "rules" on the
  data that will be signed in the future. Such a permission might look like this:

  ```
  |{
  |  schemaIndex: 0,   <·· published "schema" for Eth TX (0)
  |  typeIndex: 0,     <·· ETh TX type.  0: standard TX (empty data)
  |  rules: [
  |    null    , null         , null,
  |    null    , null         , null,
  |    null    , null         , null,
  |    'equals', '0x397654..' , null,  <·· recipient
  |    'equals', 1000         , null,  <·· wei ammount
  |    'equals', ''           , null,
  |       ^         ^            ^
  |    typeOfRule  value1      value2
  |  ],
  |  timeLimit: 10000                  <·· secs elapsed
  |}                                       between requests
  ```

* specific rules `[ nonce, gas, gasPrice, to, value, data ]`
* Requester can only send a request once every 10_000 seconds.  (~ 2h 40min)

### Grid+ Application SDK:
* OOSS node.js module.
* Example  mobile wallet application also provided as example.
* JS code snippet: (WiP: 2018)
  ```
  | const Sdk = require('gridplus-sdk');
  | const sdk = new Sdk({
  |      btcNode: 'localhost:48332', ethNode: 'localhost:8545' 
  | });
  |
  | const req = {
  |   type: 'eth-transfer',
  |   rules: {
  |     value: { 'equals': 1000 },
  |     to: { 'equals': '0x39765400baa16dbcd1d7b473bac4d55dd5a7cffb' }
  |   },
  |   interval: 10000
  | }
  |
  | sdk.createAutomaticPermission(req, (err, res) => {
  |   ... do stuff ...
  | })
  ```
[[secret_mng.hardware.lattice1}]]

## "Top" hard.Wallets <!-- { top hardware wallets -->
(WARM: Last update 2018, but still relevant as of 2022)
### Ledger Nano
* <https://shop.ledger.com/products/ledger-nano-s>
* securised key store system:
  * WYSIWYS/BOLOS:
  * Fully-certified by ANSSI, the French cybersecurity agency.
  * Backup:  crypto assets stay safe even if you lose Ledger Nano S.
    A confidential recovery phrase backs up your device,
    and your accounts can easily be restored on any Ledger device.
### KeepKey
* Controlled through Google Chrome.
<https://shapeshift.io/keepkey/>
* Recovery method?
### Safe T-Mini (Archos)
* "Notre avis complet sur le Safe T-mini"
* <https://shop.archos.com/es/hardware-wallet/588-archos-safe-t-mini.html>
* Recovery method?
### Ledger Blue:
* <https://shop.ledger.com/products/ledger-blue>
* architecture double-chip.
* To validate TXs, it can comunicate through USB/Bluethooth.
* Targeting business.
* "Big" screen for easy ussage.
*   Recovery method?
### CoolBitX CoolWallet
* <https://www.coolwallet.io/>
* Credit Card format
* Recovery method?
### Trezor Wallet
* <https://en.bitcoin.it/wiki/TREZOR>
* BIP 0032 Deterministic hardware wallet.
* TREZOR is basically a small computer. It is designed to
  protect your private keys from possible online and
  offline risks.
* Recovery method?
<!-- top hardware wallets } -->
[[secret_mng.wallets}]]

## Gemalto: Data protection AaS [[{secret_mng.hardware}]]

* <https://safenet.gemalto.com/resources/data-protection/data-protection-as-a-service-suite-solution-brief/>


# Vault services & KMS 

[[{PM.TODO]]
## HashiCorp Vault Project
  https://www.vaultproject.io/
"""HashiCorp Vault secures, stores, and tightly controls
  access to tokens, passwords, certificates, API keys, and
  other secrets in modern computing. Vault handles leasing,
  key revocation, key rolling, and auditing. Through a
  unified API, users can access an encrypted Key/Value
  store and network encryption-as-a-service, or generate
  AWS IAM/STS credentials, SQL/NoSQL databases, X.509
  certificates, SSH credentials, and more. "

* https://github.com/hashicorp/vault">Vault@Github

## Keywhiz
<https://square.github.io/keywhiz/>

## Crypt
<https://xordataexchange.github.io/crypt/>
(in combination with with etcd or consul)

## Key Management Services

- Azure Key Vault   : Allows for "many-keys"  per Vault resource with a
  very low cost.
- Amazon KMS        : very simple, single key per KMS. An (very) expensive
  CloudHSM is needed for the "many keys" use-case.
- Google Cloud KMS  :

# Mobile and IoT Keystores:

## Android Keystore 
* See Android docs

## Apple iOS KeyChain:
* See iOS docs

#
[[}]]
